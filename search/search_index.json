{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Embedded Systems course Definition An embedded system is a specialized computer system\u2014a combination of a computer processor, computer memory, and input/output peripheral devices\u2014that has a dedicated function within a larger mechanical or electronic system. It is embedded as part of a complete device often including electrical or electronic hardware and mechanical parts. Because an embedded system typically controls physical operations of the machine that it is embedded within, it often has real-time computing constraints. @Wikipedia Objectives The main objective of this course is to learn how to create your own embedded image of Operating System (OS) Subjects include : the configuration of the network interface of an embedded system how to test and modify the embedded OS directly on your host machine (QEMU, mounting, etc) containerization (Docker) References Most of the content of this course was written by Beno\u00eet Zerr, the previous teacher, and is based on his slides.","title":"Home"},{"location":"#welcome-to-the-embedded-systems-course","text":"","title":"Welcome to the Embedded Systems course"},{"location":"#definition","text":"An embedded system is a specialized computer system\u2014a combination of a computer processor, computer memory, and input/output peripheral devices\u2014that has a dedicated function within a larger mechanical or electronic system. It is embedded as part of a complete device often including electrical or electronic hardware and mechanical parts. Because an embedded system typically controls physical operations of the machine that it is embedded within, it often has real-time computing constraints. @Wikipedia","title":"Definition"},{"location":"#objectives","text":"The main objective of this course is to learn how to create your own embedded image of Operating System (OS) Subjects include : the configuration of the network interface of an embedded system how to test and modify the embedded OS directly on your host machine (QEMU, mounting, etc) containerization (Docker)","title":"Objectives"},{"location":"#references","text":"Most of the content of this course was written by Beno\u00eet Zerr, the previous teacher, and is based on his slides.","title":"References"},{"location":"image/qemu/","text":"Introduction to QEMU Introduction QEMU , which stands for Quick Emulator , is an open-source software project that provides an emulation and virtualization framework. It is designed to run a variety of guest operating systems on a host operating system, and can emulate a wide range of hardware platforms. QEMU has been created by Fabrice Bellard (also known for ffmpeg) QEMU can be used for a variety of purposes, including: Running legacy operating systems or software on modern hardware. Running multiple operating systems on a single host machine for testing or development purposes. Providing a safe and isolated environment for running untrusted or potentially malicious code. Developing and testing software for embedded devices or other specialized hardware platforms. Visit QEMU website to learn more How QEMU works QEMU works by emulating the hardware components of a computer, including the CPU, memory, storage devices, network adapters, and input/output devices. When a guest operating system is started, it runs on top of the emulated hardware, just as it would on a physical machine. The guest operating system sees the emulated hardware as if it were real, and interacts with it accordingly. QEMU can also provide virtualization capabilities, allowing multiple operating systems to run on a single host machine with minimal performance overhead. In this mode, QEMU uses hardware virtualization extensions (such as Intel VT-x or AMD-V) to provide isolated environments for each guest operating system. Using QEMU QEMU is a powerful and versatile tool that can be used for a variety of purposes, from running legacy software to testing new operating systems. With its ease of use and wide range of features, QEMU is a must-have tool for any system administrator or developer. Install sudo apt-get install qemu-system qemu-user-static binfmt-support","title":"Introduction to QEMU"},{"location":"image/qemu/#introduction-to-qemu","text":"","title":"Introduction to QEMU"},{"location":"image/qemu/#introduction","text":"QEMU , which stands for Quick Emulator , is an open-source software project that provides an emulation and virtualization framework. It is designed to run a variety of guest operating systems on a host operating system, and can emulate a wide range of hardware platforms. QEMU has been created by Fabrice Bellard (also known for ffmpeg) QEMU can be used for a variety of purposes, including: Running legacy operating systems or software on modern hardware. Running multiple operating systems on a single host machine for testing or development purposes. Providing a safe and isolated environment for running untrusted or potentially malicious code. Developing and testing software for embedded devices or other specialized hardware platforms. Visit QEMU website to learn more","title":"Introduction"},{"location":"image/qemu/#how-qemu-works","text":"QEMU works by emulating the hardware components of a computer, including the CPU, memory, storage devices, network adapters, and input/output devices. When a guest operating system is started, it runs on top of the emulated hardware, just as it would on a physical machine. The guest operating system sees the emulated hardware as if it were real, and interacts with it accordingly. QEMU can also provide virtualization capabilities, allowing multiple operating systems to run on a single host machine with minimal performance overhead. In this mode, QEMU uses hardware virtualization extensions (such as Intel VT-x or AMD-V) to provide isolated environments for each guest operating system.","title":"How QEMU works"},{"location":"image/qemu/#using-qemu","text":"QEMU is a powerful and versatile tool that can be used for a variety of purposes, from running legacy software to testing new operating systems. With its ease of use and wide range of features, QEMU is a must-have tool for any system administrator or developer.","title":"Using QEMU"},{"location":"image/qemu/#install","text":"sudo apt-get install qemu-system qemu-user-static binfmt-support","title":"Install"},{"location":"image/lab1/executing/","text":"E. Executing commands on the Raspberry Pi OS image Introduction Changing values in configuration files in the image on host is fairly easy (as seen before) But what about running a command in the image on host? for example to change the password ? Problem 1 Host executes X86 code while image contains ARM executables Solution : emulating ARM on X86 with QEMU (created by Fabrice Bellard) --> Read Introduction to QEMU Problem 2 Host commands are under / (ex /bin/bash) while image commands are under /mnt/rpi (ex /mnt/rpi/bin/bash). Solution : changing the root (/) using chroot, introduced in development of Version 7 Unix in 1979. Starting chroot Standard process Prepare the Raspberry Pi OS image to be executed it on host ... First we need to mount the system folder the same way they are mounted on the real Raspberry Pi board Mount the image in a loop device (we use /dev/loop50 as before) sudo losetup -P /dev/loop50 imgs/2024-11-19-raspios-bookworm-arm64-lite.img Mount the partitions (as before) sudo mount /dev/loop50p2 /mnt/rpi sudo mount /dev/loop50p1 /mnt/rpi/boot Mount the system folders to make them similar as if we were executing on the actual Raspberry board for example, /dev is an important folder that gives access to all the devices : /mnt/rpi/dev must be translated to /dev sudo mount --bind /dev /mnt/rpi/dev/ 1 - Issue Do the same for all the other system folders we need : /sys , which is an interface to the kernel /proc , which is a virtual file system working as an interface to ongoing processes 1 - Solution sudo mount --bind /sys /mnt/rpi/sys/ sudo mount --bind /proc /mnt/rpi/proc/ Note A PTY (pseudo-terminal) is a kernel feature that lets programs behave as if they are attached to a real terminal. Examples of things that require PTYs: interactive shells (bash, sh) sudo ssh su screen, tmux apt / dpkg (often indirectly) systemctl So in a chroot, no PTYs = lots of weird failures. PTYs (/dev/pts/*), pseudo-terminals are provided by the devpts filesystem. Mount it using : mkdir -p /mnt/rpi/dev/pts sudo mount -t devpts devpts /mnt/rpi/dev/pts Warning If you get a PTY error, reboot your computer and avoid the previous step Note We need to disable some specific actions done solely on the real board. The /etc/ld.so.preload file tells what libraries should be loaded before the other. This does not work on the virtual Raspberry Pi. On modern Debian-based systems (including Raspberry Pi OS Bookworm = Debian 12) : /etc/ld.so.preload is optional It is not created by default The dynamic linker only reads it if it exists The file /etc/ld.so.preload should only be executed on actual board. Check if there is such a file : ls /mnt/rpi/etc/ld.so.preload It should return nothing. If it returns /mnt/rpi/etc/ld.so.preload , it means you are using an old version, then for safety keep a backup version and comment the content of /mnt/rpi/etc/ld.so.preload . We also need to add QEMU to translate ARM code to X86 64 code so it can be executed on the host computer. QEMU is added by just copying the emulator in the Raspberry Pi OS image : sudo cp /usr/bin/qemu-arm-static /mnt/rpi/usr/bin/ Warning Make sure you installed QEMU following Introduction to QEMU instructions Using host network in chroot For some applications, we may need access to Internet. A practical example is the use of the packet manager with apt We need to copy some of the host configuration files (here /etc/resolv.conf) on the image before running chroot First save the current config as a backup sudo cp /mnt/rpi/etc/resolv.conf /mnt/rpi/etc/resolv.conf.bck Copy config from host sudo cp /etc/resolv.conf /mnt/rpi/etc/resolv.conf Now all should be prepared correctly. start_chroot.bash To avoid reapeating the previous series of commands and make more easy the use of chroot we can create a bash script to run before chroot : start_chroot.bash . Example of a starting script. Create the file start_chroot.bash in rpilab. nano start_chroot.bash And copy the following : #!/bin/bash # command parameter ($1) is the path to the RPI image file # example of use : # source start_chroot.bash imgs/2024-11-19-raspios-bookworm-arm64-lite.img sudo losetup -P /dev/loop50 $1 sudo mount /dev/loop50p2 /mnt/rpi sudo mount /dev/loop50p1 /mnt/rpi/boot sudo mount --bind /dev /mnt/rpi/dev/ sudo mount --bind /sys /mnt/rpi/sys/ sudo mount --bind /proc /mnt/rpi/proc/ sudo mount -t devpts devpts /mnt/rpi/dev/pts sudo cp /usr/bin/qemu-arm-static /mnt/rpi/usr/bin/ sudo cp /mnt/rpi/etc/resolv.conf /mnt/rpi/etc/resolv.conf.bck sudo cp /etc/resolv.conf /mnt/rpi/etc/resolv.conf Run chroot We can now chroot and run the RPI image as if it was on a actual board ! /mnt/rpi will be our new / and we execute /bin/bash to start a terminal 2 - Issue Use chroot to make /mnt/rpi the new root and start a bash terminal Tip The /bin/bash command is used to open a new bash shell 2 - Solution sudo chroot /mnt/rpi /bin/bash We have now a root prompt # and we can execute commands on the RPI image, for example : to create an new user ue41 with root privileges (sudo) set locale to en US.UTF-8 using raspi-config (5 Localisation options) set keyboard to French layout using raspi-config to enable the console with raspi-config (to access the actual RPI board without network) for future use with real board (may be done later) run apt update Tip To leave the chroot shell, use Ctrl + D Note With some experience, we can do most of the setup of the RPI image without using the actual board !!! Adding a sudo user with chroot To do this, we make sure we are in chroot (# prompt) on the Raspberry PI OS, and we will proceed in two steps : We will create a new user called ue41, password ue41. (no need to answer all the questions !!! most of them can be left empty) 3 - Issue Use adduser to create the ue41 user 3 - Solution adduser ue41 Execute visudo command to give sudo permission to the created user visudo A file should open. Add a line with ue41 user here : %sudo ALL=(ALL:ALL) ALL ue41 ALL=(ALL:ALL) ALL Then write and save (nano commands) Enabling the Serial interface and RPI console for debug The console is an easy tool for debug, it can be connected to the host via FTDI USB cable and can be accessed on Ubuntu via /dev/ttyUSB0 device. Hence, it can work even if the network is not or badly defined. To enable the console, Raspberry Pi OS offers several ways : adding the line enable_uart=1 at the end of the file /mnt/rpi/boot/config.txt with standard mount of boot partition, adding the line enable_uart=1 at the end of the file /boot/config.txt in chroot mode Warning UPDATE - After verification, the following does not work well even with QEMU. raspi-config needs a real Raspberry Pi kernel, so it works only on a real board To avoid any unexpected behaviour, we will prefer manual configuration (see after this warning) As we have started chroot, we will use the raspi-config tool. Simply execute raspi-config under chroot prompt # raspi-config Then go in Interface Options and enable Serial Port . More details on raspi-config Documetation Note raspi-config can be used to easily configure a lot of features such as the network, the locale language, etc As we have started chroot, we will directly modify the /boot/config.txt file. Add the line enable_uart=1 in /boot/config.txt using nano. Clean termination of chroot Standard process To exit chroot, just type ctrl+D or exit . To return to a standard host configuration we have to : go back to the original network config if we used the host's uncomment actions in /mnt/rpi/etc/ld.so.preload if we did so unmount all the RPI image system folders stop the loop device with RPI image Restore the network config sudo cp /mnt/rpi/etc/resolv.conf.bck /mnt/rpi/etc/resolv.conf Unmount all volumes at once sudo umount /mnt/rpi/ { dev/pts,dev,sys,proc,boot, } Stop the loop device with RPI image sudo losetup -d /dev/loop50 stop_chroot.bash Just like we did for starting chroot we can create a bash script to run after chroot: stop_chroot.bash 4 - Issue Write a stop_chroot.bash script to cleanly return to the standard host configuration. 4 - Solution Create the file stop_chroot.bash . nano stop_chroot.bash And copy the following : #!/bin/bash # usage : # source stop_chroot.bash sudo cp /mnt/rpi/etc/resolv.conf.bck /mnt/rpi/etc/resolv.conf sudo umount /mnt/rpi/ { dev/pts,dev,sys,proc,boot, } sudo losetup -d /dev/loop50 Run apt command in chroot Now with the scripts you should be able to only use the following : source start_chroot.bash imgs/2024-11-19-raspios-bookworm-arm64-lite.img sudo chroot /mnt/rpi /bin/bash apt update # type ctrl-D to exit chroot source stop_chroot.bash Congrats ! You successfully ended this lab ! Keep your modified image on your computer as it will be used in a next lab.","title":"E. Executing commands on the Raspberry Pi OS image"},{"location":"image/lab1/executing/#e-executing-commands-on-the-raspberry-pi-os-image","text":"","title":"E. Executing commands on the Raspberry Pi OS image"},{"location":"image/lab1/executing/#introduction","text":"Changing values in configuration files in the image on host is fairly easy (as seen before) But what about running a command in the image on host? for example to change the password ? Problem 1 Host executes X86 code while image contains ARM executables Solution : emulating ARM on X86 with QEMU (created by Fabrice Bellard) --> Read Introduction to QEMU Problem 2 Host commands are under / (ex /bin/bash) while image commands are under /mnt/rpi (ex /mnt/rpi/bin/bash). Solution : changing the root (/) using chroot, introduced in development of Version 7 Unix in 1979.","title":"Introduction"},{"location":"image/lab1/executing/#starting-chroot","text":"","title":"Starting chroot"},{"location":"image/lab1/executing/#standard-process","text":"Prepare the Raspberry Pi OS image to be executed it on host ... First we need to mount the system folder the same way they are mounted on the real Raspberry Pi board Mount the image in a loop device (we use /dev/loop50 as before) sudo losetup -P /dev/loop50 imgs/2024-11-19-raspios-bookworm-arm64-lite.img Mount the partitions (as before) sudo mount /dev/loop50p2 /mnt/rpi sudo mount /dev/loop50p1 /mnt/rpi/boot Mount the system folders to make them similar as if we were executing on the actual Raspberry board for example, /dev is an important folder that gives access to all the devices : /mnt/rpi/dev must be translated to /dev sudo mount --bind /dev /mnt/rpi/dev/ 1 - Issue Do the same for all the other system folders we need : /sys , which is an interface to the kernel /proc , which is a virtual file system working as an interface to ongoing processes 1 - Solution sudo mount --bind /sys /mnt/rpi/sys/ sudo mount --bind /proc /mnt/rpi/proc/ Note A PTY (pseudo-terminal) is a kernel feature that lets programs behave as if they are attached to a real terminal. Examples of things that require PTYs: interactive shells (bash, sh) sudo ssh su screen, tmux apt / dpkg (often indirectly) systemctl So in a chroot, no PTYs = lots of weird failures. PTYs (/dev/pts/*), pseudo-terminals are provided by the devpts filesystem. Mount it using : mkdir -p /mnt/rpi/dev/pts sudo mount -t devpts devpts /mnt/rpi/dev/pts Warning If you get a PTY error, reboot your computer and avoid the previous step Note We need to disable some specific actions done solely on the real board. The /etc/ld.so.preload file tells what libraries should be loaded before the other. This does not work on the virtual Raspberry Pi. On modern Debian-based systems (including Raspberry Pi OS Bookworm = Debian 12) : /etc/ld.so.preload is optional It is not created by default The dynamic linker only reads it if it exists The file /etc/ld.so.preload should only be executed on actual board. Check if there is such a file : ls /mnt/rpi/etc/ld.so.preload It should return nothing. If it returns /mnt/rpi/etc/ld.so.preload , it means you are using an old version, then for safety keep a backup version and comment the content of /mnt/rpi/etc/ld.so.preload . We also need to add QEMU to translate ARM code to X86 64 code so it can be executed on the host computer. QEMU is added by just copying the emulator in the Raspberry Pi OS image : sudo cp /usr/bin/qemu-arm-static /mnt/rpi/usr/bin/ Warning Make sure you installed QEMU following Introduction to QEMU instructions","title":"Standard process"},{"location":"image/lab1/executing/#using-host-network-in-chroot","text":"For some applications, we may need access to Internet. A practical example is the use of the packet manager with apt We need to copy some of the host configuration files (here /etc/resolv.conf) on the image before running chroot First save the current config as a backup sudo cp /mnt/rpi/etc/resolv.conf /mnt/rpi/etc/resolv.conf.bck Copy config from host sudo cp /etc/resolv.conf /mnt/rpi/etc/resolv.conf Now all should be prepared correctly.","title":"Using host network in chroot"},{"location":"image/lab1/executing/#start_chrootbash","text":"To avoid reapeating the previous series of commands and make more easy the use of chroot we can create a bash script to run before chroot : start_chroot.bash . Example of a starting script. Create the file start_chroot.bash in rpilab. nano start_chroot.bash And copy the following : #!/bin/bash # command parameter ($1) is the path to the RPI image file # example of use : # source start_chroot.bash imgs/2024-11-19-raspios-bookworm-arm64-lite.img sudo losetup -P /dev/loop50 $1 sudo mount /dev/loop50p2 /mnt/rpi sudo mount /dev/loop50p1 /mnt/rpi/boot sudo mount --bind /dev /mnt/rpi/dev/ sudo mount --bind /sys /mnt/rpi/sys/ sudo mount --bind /proc /mnt/rpi/proc/ sudo mount -t devpts devpts /mnt/rpi/dev/pts sudo cp /usr/bin/qemu-arm-static /mnt/rpi/usr/bin/ sudo cp /mnt/rpi/etc/resolv.conf /mnt/rpi/etc/resolv.conf.bck sudo cp /etc/resolv.conf /mnt/rpi/etc/resolv.conf","title":"start_chroot.bash"},{"location":"image/lab1/executing/#run-chroot","text":"We can now chroot and run the RPI image as if it was on a actual board ! /mnt/rpi will be our new / and we execute /bin/bash to start a terminal 2 - Issue Use chroot to make /mnt/rpi the new root and start a bash terminal Tip The /bin/bash command is used to open a new bash shell 2 - Solution sudo chroot /mnt/rpi /bin/bash We have now a root prompt # and we can execute commands on the RPI image, for example : to create an new user ue41 with root privileges (sudo) set locale to en US.UTF-8 using raspi-config (5 Localisation options) set keyboard to French layout using raspi-config to enable the console with raspi-config (to access the actual RPI board without network) for future use with real board (may be done later) run apt update Tip To leave the chroot shell, use Ctrl + D Note With some experience, we can do most of the setup of the RPI image without using the actual board !!!","title":"Run chroot"},{"location":"image/lab1/executing/#adding-a-sudo-user-with-chroot","text":"To do this, we make sure we are in chroot (# prompt) on the Raspberry PI OS, and we will proceed in two steps : We will create a new user called ue41, password ue41. (no need to answer all the questions !!! most of them can be left empty) 3 - Issue Use adduser to create the ue41 user 3 - Solution adduser ue41 Execute visudo command to give sudo permission to the created user visudo A file should open. Add a line with ue41 user here : %sudo ALL=(ALL:ALL) ALL ue41 ALL=(ALL:ALL) ALL Then write and save (nano commands)","title":"Adding a sudo user with chroot"},{"location":"image/lab1/executing/#enabling-the-serial-interface-and-rpi-console-for-debug","text":"The console is an easy tool for debug, it can be connected to the host via FTDI USB cable and can be accessed on Ubuntu via /dev/ttyUSB0 device. Hence, it can work even if the network is not or badly defined. To enable the console, Raspberry Pi OS offers several ways : adding the line enable_uart=1 at the end of the file /mnt/rpi/boot/config.txt with standard mount of boot partition, adding the line enable_uart=1 at the end of the file /boot/config.txt in chroot mode Warning UPDATE - After verification, the following does not work well even with QEMU. raspi-config needs a real Raspberry Pi kernel, so it works only on a real board To avoid any unexpected behaviour, we will prefer manual configuration (see after this warning) As we have started chroot, we will use the raspi-config tool. Simply execute raspi-config under chroot prompt # raspi-config Then go in Interface Options and enable Serial Port . More details on raspi-config Documetation Note raspi-config can be used to easily configure a lot of features such as the network, the locale language, etc As we have started chroot, we will directly modify the /boot/config.txt file. Add the line enable_uart=1 in /boot/config.txt using nano.","title":"Enabling the Serial interface and RPI console for debug"},{"location":"image/lab1/executing/#clean-termination-of-chroot","text":"","title":"Clean termination of chroot"},{"location":"image/lab1/executing/#standard-process_1","text":"To exit chroot, just type ctrl+D or exit . To return to a standard host configuration we have to : go back to the original network config if we used the host's uncomment actions in /mnt/rpi/etc/ld.so.preload if we did so unmount all the RPI image system folders stop the loop device with RPI image Restore the network config sudo cp /mnt/rpi/etc/resolv.conf.bck /mnt/rpi/etc/resolv.conf Unmount all volumes at once sudo umount /mnt/rpi/ { dev/pts,dev,sys,proc,boot, } Stop the loop device with RPI image sudo losetup -d /dev/loop50","title":"Standard process"},{"location":"image/lab1/executing/#stop_chrootbash","text":"Just like we did for starting chroot we can create a bash script to run after chroot: stop_chroot.bash 4 - Issue Write a stop_chroot.bash script to cleanly return to the standard host configuration. 4 - Solution Create the file stop_chroot.bash . nano stop_chroot.bash And copy the following : #!/bin/bash # usage : # source stop_chroot.bash sudo cp /mnt/rpi/etc/resolv.conf.bck /mnt/rpi/etc/resolv.conf sudo umount /mnt/rpi/ { dev/pts,dev,sys,proc,boot, } sudo losetup -d /dev/loop50","title":"stop_chroot.bash"},{"location":"image/lab1/executing/#run-apt-command-in-chroot","text":"Now with the scripts you should be able to only use the following : source start_chroot.bash imgs/2024-11-19-raspios-bookworm-arm64-lite.img sudo chroot /mnt/rpi /bin/bash apt update # type ctrl-D to exit chroot source stop_chroot.bash Congrats ! You successfully ended this lab ! Keep your modified image on your computer as it will be used in a next lab.","title":"Run apt command in chroot"},{"location":"image/lab1/getting/","text":"A. Getting the Raspberry Pi OS image Create the working directory mkdir rpilab && cd rpilab Create a folder for the images mkdir imgs && cd imgs Let's choose the \"lite\" version of raspios bookworm (from 2024, November 19th) 1 - Issue Download the image in the lab from the official website: https://www.raspberrypi.com/software/operating-systems/ Click on \"View archive\" to get this version and download it using the wget command. 1 - Solution wget https://downloads.raspberrypi.com/raspios_lite_arm64/images/raspios_lite_arm64-2024-11-19/2024-11-19-raspios-bookworm-arm64-lite.img.xz Now, we want to check the checksum to ensure data integrity and avoid any problem during the download 2 - Issue Download the cheksum file ( .sha256 file) using wget Compute the checksum using the sha256sum command Verify that the resulting code is the same as the one contained in the .sha256 file, using cat to display the file's content in the shell 2 - Solution First, we download the checksum file wget https://downloads.raspberrypi.com/raspios_lite_arm64/images/raspios_lite_arm64-2024-11-19/2024-11-19-raspios-bookworm-arm64-lite.img.xz.sha256 Then, we compute the checksum sha256sum 2024 -11-19-raspios-bookworm-arm64-lite.img.xz Finally, we check that the code is the same cat 2024 -11-19-raspios-bookworm-arm64-lite.img.xz.sha256 3 - Issue We can now safely decrompress the image using xz . 3 - Solution xz -d 2024 -11-19-raspios-bookworm-arm64-lite.img.xz We go back in the lab folder cd ..","title":"A. Getting the Raspberry Pi OS image"},{"location":"image/lab1/getting/#a-getting-the-raspberry-pi-os-image","text":"Create the working directory mkdir rpilab && cd rpilab Create a folder for the images mkdir imgs && cd imgs Let's choose the \"lite\" version of raspios bookworm (from 2024, November 19th) 1 - Issue Download the image in the lab from the official website: https://www.raspberrypi.com/software/operating-systems/ Click on \"View archive\" to get this version and download it using the wget command. 1 - Solution wget https://downloads.raspberrypi.com/raspios_lite_arm64/images/raspios_lite_arm64-2024-11-19/2024-11-19-raspios-bookworm-arm64-lite.img.xz Now, we want to check the checksum to ensure data integrity and avoid any problem during the download 2 - Issue Download the cheksum file ( .sha256 file) using wget Compute the checksum using the sha256sum command Verify that the resulting code is the same as the one contained in the .sha256 file, using cat to display the file's content in the shell 2 - Solution First, we download the checksum file wget https://downloads.raspberrypi.com/raspios_lite_arm64/images/raspios_lite_arm64-2024-11-19/2024-11-19-raspios-bookworm-arm64-lite.img.xz.sha256 Then, we compute the checksum sha256sum 2024 -11-19-raspios-bookworm-arm64-lite.img.xz Finally, we check that the code is the same cat 2024 -11-19-raspios-bookworm-arm64-lite.img.xz.sha256 3 - Issue We can now safely decrompress the image using xz . 3 - Solution xz -d 2024 -11-19-raspios-bookworm-arm64-lite.img.xz We go back in the lab folder cd ..","title":"A. Getting the Raspberry Pi OS image"},{"location":"image/lab1/increasing/","text":"C. Increasing size of Raspberry Pi OS image Suppose that we are in the rpilab folder, go to imgs subfolder : cd imgs Extend partition 2 (rootfs) with 2 GB (choose one of the two methods) method 1 truncate --size = +2G 2024 -11-19-raspios-bookworm-arm64-lite.img method 2 dd if = /dev/zero bs = 1M count = 2048 >> 2024 -11-19-raspios-bookworm-arm64-lite.img Check that partition 2 has not been resized yet sudo fdisk -l 2024 -11-19-raspios-bookworm-arm64-lite.img Then, use parted to actually extend the partition 2 sudo parted 2024 -11-19-raspios-bookworm-arm64-lite.img On the command prompt,type: p resizepart 2 -1 p q Mount the image in a loop device (we use /dev/loop50 as before) sudo losetup -P /dev/loop50 2024 -11-19-raspios-bookworm-arm64-lite.img Check file system and extend file system to fully fill partition 2 sudo e2fsck -f /dev/loop50p2 sudo resize2fs /dev/loop50p2 Detach cleanly sudo losetup -d /dev/loop50 back to rpilab folder cd ..","title":"C. Increasing size of Raspberry Pi OS image"},{"location":"image/lab1/increasing/#c-increasing-size-of-raspberry-pi-os-image","text":"Suppose that we are in the rpilab folder, go to imgs subfolder : cd imgs Extend partition 2 (rootfs) with 2 GB (choose one of the two methods) method 1 truncate --size = +2G 2024 -11-19-raspios-bookworm-arm64-lite.img method 2 dd if = /dev/zero bs = 1M count = 2048 >> 2024 -11-19-raspios-bookworm-arm64-lite.img Check that partition 2 has not been resized yet sudo fdisk -l 2024 -11-19-raspios-bookworm-arm64-lite.img Then, use parted to actually extend the partition 2 sudo parted 2024 -11-19-raspios-bookworm-arm64-lite.img On the command prompt,type: p resizepart 2 -1 p q Mount the image in a loop device (we use /dev/loop50 as before) sudo losetup -P /dev/loop50 2024 -11-19-raspios-bookworm-arm64-lite.img Check file system and extend file system to fully fill partition 2 sudo e2fsck -f /dev/loop50p2 sudo resize2fs /dev/loop50p2 Detach cleanly sudo losetup -d /dev/loop50 back to rpilab folder cd ..","title":"C. Increasing size of Raspberry Pi OS image"},{"location":"image/lab1/intro/","text":"Lab 1 - Introduction Objectives Setting-up Raspberry Pi OS Image Getting the Raspberry Pi OS (formerly Raspbian) image Modifying the image on the host OS (ex. increasing size, changing settings) Executing commands on the image on the host computer (ex. adding a sudo user, raspi-config) Note The host or the host computer is the physical machine on which you will execute the Raspberry Pi OS. In this lab it is your laptop. Raspberry Pi 3B Overview : The Raspberry Pi is a small single-board computer developed in the UK by the Raspberry Pi Foundation. The Raspberry Pi 3 Model B is one of the most popular versions. It offers a low-cost, compact solution for various computing projects. Specifications : CPU: Quad-core 1.2GHz Broadcom BCM2837 64-bit ARM Cortex-A53 processor RAM: 1GB LPDDR2 Connectivity: 4 USB 2.0 ports 1 HDMI port 1 Ethernet port 3.5mm audio jack Wi-Fi 802.11n and Bluetooth 4.1 GPIO: 40-pin GPIO header Applications : Home automation Robotics IoT projects Media center Education Retro gaming console Linux on RPI Very basic behavior description : Linux comes as an image file (Raspberry Pi OS, Ubuntu, Fedora, Manjaro ARM, ...) We will use the official image Raspberry Pi OS On real boards, the image is written on a SD-CARD The Raspberry Pi OS image contains 2 partitions : boot and rootfs The boot partition contains all the important elements for starting linux : boot loader (bootcode.bin), Device Tree Blob (.dtb) , kernel (kernelx.img), starting command (cmdline.txt) , configuration (config.txt) ... The rootfs partition contains file system : /etc /lib /usr/lib, /bin /dev /opt /home ... Lab presentation In this lab you are asked to follow given instructions. Sometimes, you will meet issues you need to solve. There are tips to help you. The solutions will be displayed after the class.","title":"Lab 1 - Introduction"},{"location":"image/lab1/intro/#lab-1-introduction","text":"","title":"Lab 1 - Introduction"},{"location":"image/lab1/intro/#objectives","text":"Setting-up Raspberry Pi OS Image Getting the Raspberry Pi OS (formerly Raspbian) image Modifying the image on the host OS (ex. increasing size, changing settings) Executing commands on the image on the host computer (ex. adding a sudo user, raspi-config) Note The host or the host computer is the physical machine on which you will execute the Raspberry Pi OS. In this lab it is your laptop.","title":"Objectives"},{"location":"image/lab1/intro/#raspberry-pi-3b","text":"Overview : The Raspberry Pi is a small single-board computer developed in the UK by the Raspberry Pi Foundation. The Raspberry Pi 3 Model B is one of the most popular versions. It offers a low-cost, compact solution for various computing projects. Specifications : CPU: Quad-core 1.2GHz Broadcom BCM2837 64-bit ARM Cortex-A53 processor RAM: 1GB LPDDR2 Connectivity: 4 USB 2.0 ports 1 HDMI port 1 Ethernet port 3.5mm audio jack Wi-Fi 802.11n and Bluetooth 4.1 GPIO: 40-pin GPIO header Applications : Home automation Robotics IoT projects Media center Education Retro gaming console","title":"Raspberry Pi 3B"},{"location":"image/lab1/intro/#linux-on-rpi","text":"Very basic behavior description : Linux comes as an image file (Raspberry Pi OS, Ubuntu, Fedora, Manjaro ARM, ...) We will use the official image Raspberry Pi OS On real boards, the image is written on a SD-CARD The Raspberry Pi OS image contains 2 partitions : boot and rootfs The boot partition contains all the important elements for starting linux : boot loader (bootcode.bin), Device Tree Blob (.dtb) , kernel (kernelx.img), starting command (cmdline.txt) , configuration (config.txt) ... The rootfs partition contains file system : /etc /lib /usr/lib, /bin /dev /opt /home ...","title":"Linux on RPI"},{"location":"image/lab1/intro/#lab-presentation","text":"In this lab you are asked to follow given instructions. Sometimes, you will meet issues you need to solve. There are tips to help you. The solutions will be displayed after the class.","title":"Lab presentation"},{"location":"image/lab1/modifying/","text":"D. Modifying the Raspberry Pi OS image 1 - Issue First mount the image's root file system as you have done before using losetup and mount 1 - Solution sudo losetup -P /dev/loop50 imgs/2024-11-19-raspios-bookworm-arm64-lite.img sudo mount /dev/loop50p2 /mnt/rpi Now the image is mounted, we can modify it (writing files, configuring parameters, etc). 2 - Issue Change the name raspberrypi name with the name of your choice : In the /etc/hosts file of the Raspberry Pi OS image, which is used to translate the host name into its ip address. In the /etc/hostname file of the Raspberry Pi OS image, which is used to define the hostname Warning Be careful not to modify your local OS' files, but those in /mnt/rpi 2 - Solution Change the name raspberry with the name you have chosen before : sudo nano /mnt/rpi/etc/hosts sudo nano /mnt/rpi/etc/hostname Clean end sudo umount /mnt/rpi sudo losetup -d /dev/loop50","title":"D. Modifying the Raspberry Pi OS image"},{"location":"image/lab1/modifying/#d-modifying-the-raspberry-pi-os-image","text":"1 - Issue First mount the image's root file system as you have done before using losetup and mount 1 - Solution sudo losetup -P /dev/loop50 imgs/2024-11-19-raspios-bookworm-arm64-lite.img sudo mount /dev/loop50p2 /mnt/rpi Now the image is mounted, we can modify it (writing files, configuring parameters, etc). 2 - Issue Change the name raspberrypi name with the name of your choice : In the /etc/hosts file of the Raspberry Pi OS image, which is used to translate the host name into its ip address. In the /etc/hostname file of the Raspberry Pi OS image, which is used to define the hostname Warning Be careful not to modify your local OS' files, but those in /mnt/rpi 2 - Solution Change the name raspberry with the name you have chosen before : sudo nano /mnt/rpi/etc/hosts sudo nano /mnt/rpi/etc/hostname Clean end sudo umount /mnt/rpi sudo losetup -d /dev/loop50","title":"D. Modifying the Raspberry Pi OS image"},{"location":"image/lab1/mounting/","text":"B. Mounting the Raspberry Pi OS image on the host The Raspberry Pi OS image has 2 partitions : rootfs and boot. We will now mount these partitions on the host to get access to the files and folders in the image. The boot partition contains bootloader information (used at start). The rootfs partition contains the file system of raspios bookworm. Definition Mounting a partition is the act of making the filesystem on that partition accessible at a specific location in the directory tree so the operating system can read from and write to it. We will now mount the rootfs partition on our computer to have access to the file system of raspios bookworm. Note We will go throuhg 2 different methods. The first one will teach us more how the image is structured. The second one is more efficient and recommended. First method (Intuitive) 1 - Issue Use the fdisk command with the correct option to display a list of partitions in your img file You may use sudo to get permission Tip Use fdisk -h to learn more about the existing options 1 - Solution sudo fdisk -l imgs/2024-11-19-raspios-bookworm-arm64-lite.img You must get something like: Disk imgs/2024-11-19-raspios-bookworm-arm64-lite.img: 2 .57 GiB, 2755657728 bytes, 5382144 sectors Units: sectors of 1 * 512 = 512 bytes Sector size ( logical/physical ) : 512 bytes / 512 bytes I/O size ( minimum/optimal ) : 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x8a438930 Device Boot Start End Sectors Size Id Type imgs/2024-11-19-raspios-bookworm-arm64-lite.img1 8192 1056767 1048576 512M c W95 FAT32 ( LBA ) imgs/2024-11-19-raspios-bookworm-arm64-lite.img2 1056768 5382143 4325376 2 .1G 83 Linux Get the starting point of the partitions contained in the image Here, partition 1 (boot) starts at block 8192 and partition2 (rootfs) starts at block 1056768. The block size is 512 bytes. Check yours Note Why does the first partition start at sector 8192 ? In order to leave space at the beginning for : Bootloader data Alignment (important for SD cards) This is common in Raspberry Pi images We first create an access file to mount the main partition (partition 2) on our computer sudo mkdir -p /mnt/rpi Note The /mnt mount directory is where external partitions are located when mounted on Linux Ubuntu. For example when you plug an external storage device (SSD, USB key, etc) Then we will use the mount command to mount the partitions. This is the standard way to mount a partition, i.e. to give access to the folders and files on the partition. Note mount automatically detect the partition type (linux ext4, dos, ntfs, ...). We mount partition 2 with the root file system sudo mount -o loop,offset = $(( 1056768 * 512 )) imgs/2024-11-19-raspios-bookworm-arm64-lite.img /mnt/rpi We check that the file system of Raspberry PI OS is there : ls /mnt/rpi Then we unmount the partition sudo umount /mnt/rpi We create an access file to mount the other partition (partition 1) sudo mkdir -p /mnt/rpi/boot sudo mount -o loop,offset = $(( 8192 * 512 )) imgs/2024-11-19-raspios-bookworm-arm64-lite.img /mnt/rpi/boot We can display the content of the boot folder : ls /mnt/rpi/boot and we unmount the partition to cleanly exit sudo umount /mnt/rpi/boot sudo rmdir /mnt/rpi/boot Warning The main problem of this method is that we cannot mount simultaneously the two partitions at the right places /mnt/rpi and /mnt/rpi/boot because an overlapping error occurs. Second method (Recommended) loop devices are virtual block devices that map a file to a disk-like interface. They let Linux treat a regular file as if it were a real disk or partition. We search for a non used loop device (/dev/loop??), list existing loop devices : lsblk For example /dev/loop50 is not used on my computer, I will use it here. 2 - Issue The losetup command allows controlling loop devices. Learn how to use the -P option in order to create a partitioned loop device, say /dev/loop50 from your Raspberry Pi OS image. Tip Use losetup -P <loop_device> <img> 2 - Solution sudo losetup -P /dev/loop50 imgs/2024-11-19-raspios-bookworm-arm64-lite.img The -P option find the 2 partitions and give them these names : partition 1 : /dev/loop50p1 (name: boot) partition 2 : /dev/loop50p2 (name: rootfs) Check your loop devices with lsblk 3 - Issue Create a folder to access the mount (already done before in method 1 !) Then, mount partition 2 with the root file system using mount (no need for the -o option) Finally, mount the boot partition at the right place in the root file system : look for a boot directory Tip You should use sudo mount <source> <directory> 3 - Solution Create the folder to access the mount sudo mkdir -p /mnt/rpi Then mount the file system partition (rootfs) sudo mount /dev/loop50p2 /mnt/rpi ls /mnt/rpi and mount the boot partition sudo mount /dev/loop50p1 /mnt/rpi/boot ls /mnt/rpi/boot Finally, we unmount the partitions to cleanly exit sudo umount /mnt/rpi/boot sudo umount /mnt/rpi sudo losetup -d /dev/loop50 Warning To cleanly exit : make the last 3 commands, in the right order, do not execute the next command if the previous has failed.","title":"B. Mounting the Raspberry Pi OS image on the host"},{"location":"image/lab1/mounting/#b-mounting-the-raspberry-pi-os-image-on-the-host","text":"The Raspberry Pi OS image has 2 partitions : rootfs and boot. We will now mount these partitions on the host to get access to the files and folders in the image. The boot partition contains bootloader information (used at start). The rootfs partition contains the file system of raspios bookworm. Definition Mounting a partition is the act of making the filesystem on that partition accessible at a specific location in the directory tree so the operating system can read from and write to it. We will now mount the rootfs partition on our computer to have access to the file system of raspios bookworm. Note We will go throuhg 2 different methods. The first one will teach us more how the image is structured. The second one is more efficient and recommended.","title":"B. Mounting the Raspberry Pi OS image on the host"},{"location":"image/lab1/mounting/#first-method-intuitive","text":"1 - Issue Use the fdisk command with the correct option to display a list of partitions in your img file You may use sudo to get permission Tip Use fdisk -h to learn more about the existing options 1 - Solution sudo fdisk -l imgs/2024-11-19-raspios-bookworm-arm64-lite.img You must get something like: Disk imgs/2024-11-19-raspios-bookworm-arm64-lite.img: 2 .57 GiB, 2755657728 bytes, 5382144 sectors Units: sectors of 1 * 512 = 512 bytes Sector size ( logical/physical ) : 512 bytes / 512 bytes I/O size ( minimum/optimal ) : 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x8a438930 Device Boot Start End Sectors Size Id Type imgs/2024-11-19-raspios-bookworm-arm64-lite.img1 8192 1056767 1048576 512M c W95 FAT32 ( LBA ) imgs/2024-11-19-raspios-bookworm-arm64-lite.img2 1056768 5382143 4325376 2 .1G 83 Linux Get the starting point of the partitions contained in the image Here, partition 1 (boot) starts at block 8192 and partition2 (rootfs) starts at block 1056768. The block size is 512 bytes. Check yours Note Why does the first partition start at sector 8192 ? In order to leave space at the beginning for : Bootloader data Alignment (important for SD cards) This is common in Raspberry Pi images We first create an access file to mount the main partition (partition 2) on our computer sudo mkdir -p /mnt/rpi Note The /mnt mount directory is where external partitions are located when mounted on Linux Ubuntu. For example when you plug an external storage device (SSD, USB key, etc) Then we will use the mount command to mount the partitions. This is the standard way to mount a partition, i.e. to give access to the folders and files on the partition. Note mount automatically detect the partition type (linux ext4, dos, ntfs, ...). We mount partition 2 with the root file system sudo mount -o loop,offset = $(( 1056768 * 512 )) imgs/2024-11-19-raspios-bookworm-arm64-lite.img /mnt/rpi We check that the file system of Raspberry PI OS is there : ls /mnt/rpi Then we unmount the partition sudo umount /mnt/rpi We create an access file to mount the other partition (partition 1) sudo mkdir -p /mnt/rpi/boot sudo mount -o loop,offset = $(( 8192 * 512 )) imgs/2024-11-19-raspios-bookworm-arm64-lite.img /mnt/rpi/boot We can display the content of the boot folder : ls /mnt/rpi/boot and we unmount the partition to cleanly exit sudo umount /mnt/rpi/boot sudo rmdir /mnt/rpi/boot Warning The main problem of this method is that we cannot mount simultaneously the two partitions at the right places /mnt/rpi and /mnt/rpi/boot because an overlapping error occurs.","title":"First method (Intuitive)"},{"location":"image/lab1/mounting/#second-method-recommended","text":"loop devices are virtual block devices that map a file to a disk-like interface. They let Linux treat a regular file as if it were a real disk or partition. We search for a non used loop device (/dev/loop??), list existing loop devices : lsblk For example /dev/loop50 is not used on my computer, I will use it here. 2 - Issue The losetup command allows controlling loop devices. Learn how to use the -P option in order to create a partitioned loop device, say /dev/loop50 from your Raspberry Pi OS image. Tip Use losetup -P <loop_device> <img> 2 - Solution sudo losetup -P /dev/loop50 imgs/2024-11-19-raspios-bookworm-arm64-lite.img The -P option find the 2 partitions and give them these names : partition 1 : /dev/loop50p1 (name: boot) partition 2 : /dev/loop50p2 (name: rootfs) Check your loop devices with lsblk 3 - Issue Create a folder to access the mount (already done before in method 1 !) Then, mount partition 2 with the root file system using mount (no need for the -o option) Finally, mount the boot partition at the right place in the root file system : look for a boot directory Tip You should use sudo mount <source> <directory> 3 - Solution Create the folder to access the mount sudo mkdir -p /mnt/rpi Then mount the file system partition (rootfs) sudo mount /dev/loop50p2 /mnt/rpi ls /mnt/rpi and mount the boot partition sudo mount /dev/loop50p1 /mnt/rpi/boot ls /mnt/rpi/boot Finally, we unmount the partitions to cleanly exit sudo umount /mnt/rpi/boot sudo umount /mnt/rpi sudo losetup -d /dev/loop50 Warning To cleanly exit : make the last 3 commands, in the right order, do not execute the next command if the previous has failed.","title":"Second method (Recommended)"},{"location":"image/lab2/getting/","text":"A. Getting the Raspberry Pi OS image Warning Unfortunately, there is still no working QEMU emulation specific kernel for Bookworm at the time of this Lab So, in order to learn how to emulate a Raspberry Pi with QEMU VM, we will download a Buster image. However, make sure to keep your Bookworm image from Lab 1 as we will use it in Lab 3 1 - Issue Follow the instructions in Getting the Raspberry Pi OS image from the previous lab to download and decompress the Raspberry PI OS Lite Buster version from 2021/05/07 (or 2021/05/08). 1 - Solution cd rpilab/imgs wget https://downloads.raspberrypi.org/raspios_lite_armhf/images/raspios_lite_armhf-2021-05-28/2021-05-07-raspios-buster-armhf-lite.zip unzip 2021 -05-07-raspios-buster-armhf-lite.zip cd ..","title":"A. Getting the Raspberry Pi OS image"},{"location":"image/lab2/getting/#a-getting-the-raspberry-pi-os-image","text":"Warning Unfortunately, there is still no working QEMU emulation specific kernel for Bookworm at the time of this Lab So, in order to learn how to emulate a Raspberry Pi with QEMU VM, we will download a Buster image. However, make sure to keep your Bookworm image from Lab 1 as we will use it in Lab 3 1 - Issue Follow the instructions in Getting the Raspberry Pi OS image from the previous lab to download and decompress the Raspberry PI OS Lite Buster version from 2021/05/07 (or 2021/05/08). 1 - Solution cd rpilab/imgs wget https://downloads.raspberrypi.org/raspios_lite_armhf/images/raspios_lite_armhf-2021-05-28/2021-05-07-raspios-buster-armhf-lite.zip unzip 2021 -05-07-raspios-buster-armhf-lite.zip cd ..","title":"A. Getting the Raspberry Pi OS image"},{"location":"image/lab2/installVM/","text":"B. Install QEMU ARM virtual machine (VM) Install require packages for QEMU virtual machine (QEMU VM). Update package manager sudo apt update Install packages for the QEMU VM sudo apt install qemu-system-arm qemu-kvm \\ libvirt-clients libvirt-daemon-system bridge-utils \\ virtinst libvirt-daemon virt-manager Note If you get problems with lmv2 during install, run: sudo apt purge lvm2 sudo apt install lvm2 When running Raspberry PI OS in the QEMU VM, we need the Linux kernel and drivers to be compatible with an execution on a QEMU VM instead of the actual RPI board. They are available here : https://github.com/dhruvvyas90/qemu-rpi-kernel We assume that we are in the rpilab folder clone the git repo with kernels and drivers git clone https://github.com/dhruvvyas90/qemu-rpi-kernel to avoid problems of git submodules, you can remove the .git folder rm -Rf qemu-rpi-kernel/.git","title":"B. Install QEMU ARM virtual machine (VM)"},{"location":"image/lab2/installVM/#b-install-qemu-arm-virtual-machine-vm","text":"Install require packages for QEMU virtual machine (QEMU VM). Update package manager sudo apt update Install packages for the QEMU VM sudo apt install qemu-system-arm qemu-kvm \\ libvirt-clients libvirt-daemon-system bridge-utils \\ virtinst libvirt-daemon virt-manager Note If you get problems with lmv2 during install, run: sudo apt purge lvm2 sudo apt install lvm2 When running Raspberry PI OS in the QEMU VM, we need the Linux kernel and drivers to be compatible with an execution on a QEMU VM instead of the actual RPI board. They are available here : https://github.com/dhruvvyas90/qemu-rpi-kernel We assume that we are in the rpilab folder clone the git repo with kernels and drivers git clone https://github.com/dhruvvyas90/qemu-rpi-kernel to avoid problems of git submodules, you can remove the .git folder rm -Rf qemu-rpi-kernel/.git","title":"B. Install QEMU ARM virtual machine (VM)"},{"location":"image/lab2/intro/","text":"Lab 2 - Introduction Objectives Running the Raspberry Pi OS on a virtual machine on host Getting the Raspberry Pi OS (formerly Raspbian) image Installing Virtual Machine (QEMU VM) software on the host Preparing the image to run it in the QEMU VM Executing QEMU VM Installing ROS2 from source code or using docker Note The host or the host computer is the physical machine on which you will execute the Raspberry Pi OS. In this lab it is your laptop.","title":"Lab 2 - Introduction"},{"location":"image/lab2/intro/#lab-2-introduction","text":"","title":"Lab 2 - Introduction"},{"location":"image/lab2/intro/#objectives","text":"Running the Raspberry Pi OS on a virtual machine on host Getting the Raspberry Pi OS (formerly Raspbian) image Installing Virtual Machine (QEMU VM) software on the host Preparing the image to run it in the QEMU VM Executing QEMU VM Installing ROS2 from source code or using docker Note The host or the host computer is the physical machine on which you will execute the Raspberry Pi OS. In this lab it is your laptop.","title":"Objectives"},{"location":"image/lab2/using/","text":"C. Using QEMU Virtual Machine Starting QEMU VM Raspberry Pi OS images do not boot directly in QEMU without: A custom kernel Correct DTB (a binary hardware description file that tells the Linux kernel which hardware it is running on) Proper machine type In qemu-rpi-kernel you will find kernels built specifically for QEMU emulation. As you can see, these don't go until the Bookworm version, this is why we use a Buster image The first time, we start with a shell (console /bin/bash) to configure the execution of the VM. qemu-system-arm \\ -kernel qemu-rpi-kernel/kernel-qemu-4.19.50-buster \\ -cpu arm1176 \\ -m 256 \\ -M versatilepb \\ -no-reboot \\ -serial stdio \\ -append \"root=/dev/sda2 panic=1 rootfstype=ext4 rw init=/bin/bash\" \\ -drive \"file=imgs/2021-05-07-raspios-buster-armhf-lite.img,index=0,media=disk,format=raw\" \\ -dtb qemu-rpi-kernel/versatile-pb-buster.dtb Tip Look for the default login and password on a Rapsberry Pi We add a special rule to have the disk devices named /dev/sd? instead of /dev/mmcblk? (simpler naming for the disk drives) Create the file rule file /etc/udev/rules.d/90-qemu.rules cat << EOF > /etc/udev/rules.d/90-qemu.rules KERNEL==\"sda\", SYMLINK+=\"mmcblk0\" KERNEL==\"sda?\", \\ SYMLINK+=\"mmcblk0p%n\" KERNEL==\"sda2\", SYMLINK+=\"root\" EOF Terminate the execution of VM by typing ctrl-D Executing QEMU VM We would like to be able to access the QEMU VM with ssh Problem : the VM has localhost IP address, same as host. To solve it, we use port mapping : tcp port 10022 of the host will be mapped to port 22 on the QEMU VM Then ssh will work using port 10022 and localhost qemu-system-arm \\ -kernel qemu-rpi-kernel/kernel-qemu-4.19.50-buster \\ -cpu arm1176 \\ -m 256 \\ -M versatilepb \\ -no-reboot \\ -serial stdio \\ -append \"root=/dev/sda2 panic=1 rootfstype=ext4 rw\" \\ -drive \"file=imgs/2021-05-07-raspios-buster-armhf-lite.img,index=0,media=disk,format=raw\" \\ -dtb qemu-rpi-kernel/versatile-pb-buster.dtb \\ -net nic -net user,hostfwd = tcp::10022-:22 The QEMU VM is ready to be used with 3 possible access : QEMU window, console and ssh. Tip To be untrapped in QEMU window, type ctrl-alt-g But there is still one step missing for ssh to work. Setting up network for ssh access The RPI image (even the lite one) has all softwares installed to access it via ssh. However, port 22 is not accessible by default ! We can enable ssh by adding an empty file simply called ssh in the boot folder 1 -Issue Use the QEMU VM console with user pi to create the /boot/ssh file with touch 1 - Solution Start QEMU with a shell : qemu-system-arm \\ -kernel qemu-rpi-kernel/kernel-qemu-4.19.50-buster \\ -cpu arm1176 \\ -m 256 \\ -M versatilepb \\ -no-reboot \\ -serial stdio \\ -append \"root=/dev/sda2 panic=1 rootfstype=ext4 rw init=/bin/bash\" \\ -drive \"file=imgs/2021-05-07-raspios-buster-armhf-lite.img,index=0,media=disk,format=raw\" \\ -dtb qemu-rpi-kernel/versatile-pb-buster.dtb and use sudo touch /boot/ssh then leave QEMU Note You can also use chroot with your bash scripts start_chroot.sh and stop_chroot.sh After restarting the qemu vm, the ssh command should work fine. 2 -Issue On an other terminal, connect to the QEMU VM from the host via ssh Look for the relevant ssh option to use the right port which is not the default 22. Tip The ip address is your localhost ipaddress so you can use the shortcut pi@localhost 2 - Solution ssh -p 10022 pi@localhost You can stop QEMU and delete the Buster image after this lab.","title":"C. Using QEMU Virtual Machine"},{"location":"image/lab2/using/#c-using-qemu-virtual-machine","text":"","title":"C. Using QEMU Virtual Machine"},{"location":"image/lab2/using/#starting-qemu-vm","text":"Raspberry Pi OS images do not boot directly in QEMU without: A custom kernel Correct DTB (a binary hardware description file that tells the Linux kernel which hardware it is running on) Proper machine type In qemu-rpi-kernel you will find kernels built specifically for QEMU emulation. As you can see, these don't go until the Bookworm version, this is why we use a Buster image The first time, we start with a shell (console /bin/bash) to configure the execution of the VM. qemu-system-arm \\ -kernel qemu-rpi-kernel/kernel-qemu-4.19.50-buster \\ -cpu arm1176 \\ -m 256 \\ -M versatilepb \\ -no-reboot \\ -serial stdio \\ -append \"root=/dev/sda2 panic=1 rootfstype=ext4 rw init=/bin/bash\" \\ -drive \"file=imgs/2021-05-07-raspios-buster-armhf-lite.img,index=0,media=disk,format=raw\" \\ -dtb qemu-rpi-kernel/versatile-pb-buster.dtb Tip Look for the default login and password on a Rapsberry Pi We add a special rule to have the disk devices named /dev/sd? instead of /dev/mmcblk? (simpler naming for the disk drives) Create the file rule file /etc/udev/rules.d/90-qemu.rules cat << EOF > /etc/udev/rules.d/90-qemu.rules KERNEL==\"sda\", SYMLINK+=\"mmcblk0\" KERNEL==\"sda?\", \\ SYMLINK+=\"mmcblk0p%n\" KERNEL==\"sda2\", SYMLINK+=\"root\" EOF Terminate the execution of VM by typing ctrl-D","title":"Starting QEMU VM"},{"location":"image/lab2/using/#executing-qemu-vm","text":"We would like to be able to access the QEMU VM with ssh Problem : the VM has localhost IP address, same as host. To solve it, we use port mapping : tcp port 10022 of the host will be mapped to port 22 on the QEMU VM Then ssh will work using port 10022 and localhost qemu-system-arm \\ -kernel qemu-rpi-kernel/kernel-qemu-4.19.50-buster \\ -cpu arm1176 \\ -m 256 \\ -M versatilepb \\ -no-reboot \\ -serial stdio \\ -append \"root=/dev/sda2 panic=1 rootfstype=ext4 rw\" \\ -drive \"file=imgs/2021-05-07-raspios-buster-armhf-lite.img,index=0,media=disk,format=raw\" \\ -dtb qemu-rpi-kernel/versatile-pb-buster.dtb \\ -net nic -net user,hostfwd = tcp::10022-:22 The QEMU VM is ready to be used with 3 possible access : QEMU window, console and ssh. Tip To be untrapped in QEMU window, type ctrl-alt-g But there is still one step missing for ssh to work.","title":"Executing QEMU VM"},{"location":"image/lab2/using/#setting-up-network-for-ssh-access","text":"The RPI image (even the lite one) has all softwares installed to access it via ssh. However, port 22 is not accessible by default ! We can enable ssh by adding an empty file simply called ssh in the boot folder 1 -Issue Use the QEMU VM console with user pi to create the /boot/ssh file with touch 1 - Solution Start QEMU with a shell : qemu-system-arm \\ -kernel qemu-rpi-kernel/kernel-qemu-4.19.50-buster \\ -cpu arm1176 \\ -m 256 \\ -M versatilepb \\ -no-reboot \\ -serial stdio \\ -append \"root=/dev/sda2 panic=1 rootfstype=ext4 rw init=/bin/bash\" \\ -drive \"file=imgs/2021-05-07-raspios-buster-armhf-lite.img,index=0,media=disk,format=raw\" \\ -dtb qemu-rpi-kernel/versatile-pb-buster.dtb and use sudo touch /boot/ssh then leave QEMU Note You can also use chroot with your bash scripts start_chroot.sh and stop_chroot.sh After restarting the qemu vm, the ssh command should work fine. 2 -Issue On an other terminal, connect to the QEMU VM from the host via ssh Look for the relevant ssh option to use the right port which is not the default 22. Tip The ip address is your localhost ipaddress so you can use the shortcut pi@localhost 2 - Solution ssh -p 10022 pi@localhost You can stop QEMU and delete the Buster image after this lab.","title":"Setting up network for ssh access"},{"location":"image/lab3/connecting/","text":"B. Accessing the headless RPI without network Connecting the debug console Warning Make sure the Raspberry Pi is off (not powered) before proceeding the following steps ! First, insert the sd-card in the Raspberry Pi The console will be connected on the I/O ports on the RPI board and on an USB input of the host computer. The serial to USB adapter is a FTDI USB cable with 3, 4 or 6 \u201dArduino like\u201d terminations to be plugged on the RPI board, you can find some information in the data sheet of the cable : The one with 3 terminations : https://www.mouser.fr/datasheet/2/163/DS_TTL-232R_RPi-267577.pdf The one with 6 terminations : https://cdn.robotshop.com/media/s/spa/rb-spa-432/pdf/ftdi-cable-schematic-dev-09718.pdf The one with 4 terminations : https://www.adafruit.com/product/954?srsltid=AfmBOoploJ4nyapeY4tQLdr9ZWopzSrvJaUvqjKPwxA8N61XxzHrdqi4 Warning Caution! The GPIO pins on the Raspberry Pi are NOT 5V tolerant. That means you must use a 3.3V USB-to-serial converter. Look at the GPIO pinout for the Raspberry Pi 3, and find the UART pins. Plug the 3 necessary terminations of the FTDI USB cable on the board accordingly. Now this is done, power up the board ! Set-up the FTDI USB cable connection on a serial port of the host First, let's get the name of the serial port on the host. The /dev/ directory consists of files that represent devices that are attached to the local system. Before plugin the FTDI USB cable, check the system messages : sudo dmesg and list the devices : ls /dev | grep \"tty\" Now, plug the FTDI cable and check again. dmesg should tell you about a new connection and the devices list should display a new device 1 - Issue Find the name of the serial port. It should be something like /dev/tty* Note If you are using Windows, you will need to know the COM port number connected to your USB to serial adapter, which can be found in the Device Manager 1 - Solution The name of serial port should be something like /dev/ttyUSB0 Check it works with : stty -F <serial_port_name> If the command works only with sudo, you need to be added to the dialout group, which gives full and direct access to serial ports. First, check the groups you are member of : groups If dialout is not in the list , do sudo usermod -a -G dialout $USER and restart the computer ... or not !!! if you don\u2019t want to restart the session, remember this trick (the scope of this command is only the current shell): su - $USER Warning Be careful, the su - $USER command only add you in the dialout group for the terminal where you used it. But, when you will restart your computer, all your terminals will open with your user already in dialout group, and you will not need to use su - $USER again. now dialout should be in the group list groups Access the RPI from the host Once the RPI boot has booted, we can access it from the host with tools like minicom . the speed should be 115200 bauds 2 - Issue Start minicom specifying the device name and a baudrate of 115200 using the correct options 2 - Solution minicom -b 115200 -D /dev/ttyUSB0 Note On windows use Putty is a straight-forward solution to connect to serial ports If you still pefer using minicom under WSL, you need to use usbipd but it needs more setup The first time using minicom, the \"Hardware control flow\" must be disabled : type ctrl-A then o to access the configuration select \"Serial port setup\" type F to disable Hardware Flow Control select \"Save setup as dfl\" so that next time you will not need to reconfigure finally select \"Exit\" The login prompt should appear one or two minutes after powering the RPI board. Type user and passwd to log in. You can use ue41 user you have created in Lab 1. Check your hostname is the one you set in Lab 1 : hostname","title":"B. Accessing the headless RPI without network"},{"location":"image/lab3/connecting/#b-accessing-the-headless-rpi-without-network","text":"","title":"B. Accessing the headless RPI without network"},{"location":"image/lab3/connecting/#connecting-the-debug-console","text":"Warning Make sure the Raspberry Pi is off (not powered) before proceeding the following steps ! First, insert the sd-card in the Raspberry Pi The console will be connected on the I/O ports on the RPI board and on an USB input of the host computer. The serial to USB adapter is a FTDI USB cable with 3, 4 or 6 \u201dArduino like\u201d terminations to be plugged on the RPI board, you can find some information in the data sheet of the cable : The one with 3 terminations : https://www.mouser.fr/datasheet/2/163/DS_TTL-232R_RPi-267577.pdf The one with 6 terminations : https://cdn.robotshop.com/media/s/spa/rb-spa-432/pdf/ftdi-cable-schematic-dev-09718.pdf The one with 4 terminations : https://www.adafruit.com/product/954?srsltid=AfmBOoploJ4nyapeY4tQLdr9ZWopzSrvJaUvqjKPwxA8N61XxzHrdqi4 Warning Caution! The GPIO pins on the Raspberry Pi are NOT 5V tolerant. That means you must use a 3.3V USB-to-serial converter. Look at the GPIO pinout for the Raspberry Pi 3, and find the UART pins. Plug the 3 necessary terminations of the FTDI USB cable on the board accordingly. Now this is done, power up the board !","title":"Connecting the debug console"},{"location":"image/lab3/connecting/#set-up-the-ftdi-usb-cable-connection-on-a-serial-port-of-the-host","text":"First, let's get the name of the serial port on the host. The /dev/ directory consists of files that represent devices that are attached to the local system. Before plugin the FTDI USB cable, check the system messages : sudo dmesg and list the devices : ls /dev | grep \"tty\" Now, plug the FTDI cable and check again. dmesg should tell you about a new connection and the devices list should display a new device 1 - Issue Find the name of the serial port. It should be something like /dev/tty* Note If you are using Windows, you will need to know the COM port number connected to your USB to serial adapter, which can be found in the Device Manager 1 - Solution The name of serial port should be something like /dev/ttyUSB0 Check it works with : stty -F <serial_port_name> If the command works only with sudo, you need to be added to the dialout group, which gives full and direct access to serial ports. First, check the groups you are member of : groups If dialout is not in the list , do sudo usermod -a -G dialout $USER and restart the computer ... or not !!! if you don\u2019t want to restart the session, remember this trick (the scope of this command is only the current shell): su - $USER Warning Be careful, the su - $USER command only add you in the dialout group for the terminal where you used it. But, when you will restart your computer, all your terminals will open with your user already in dialout group, and you will not need to use su - $USER again. now dialout should be in the group list groups","title":"Set-up the FTDI USB cable connection on a serial port of the host"},{"location":"image/lab3/connecting/#access-the-rpi-from-the-host","text":"Once the RPI boot has booted, we can access it from the host with tools like minicom . the speed should be 115200 bauds 2 - Issue Start minicom specifying the device name and a baudrate of 115200 using the correct options 2 - Solution minicom -b 115200 -D /dev/ttyUSB0 Note On windows use Putty is a straight-forward solution to connect to serial ports If you still pefer using minicom under WSL, you need to use usbipd but it needs more setup The first time using minicom, the \"Hardware control flow\" must be disabled : type ctrl-A then o to access the configuration select \"Serial port setup\" type F to disable Hardware Flow Control select \"Save setup as dfl\" so that next time you will not need to reconfigure finally select \"Exit\" The login prompt should appear one or two minutes after powering the RPI board. Type user and passwd to log in. You can use ue41 user you have created in Lab 1. Check your hostname is the one you set in Lab 1 : hostname","title":"Access the RPI from the host"},{"location":"image/lab3/debug/","text":"Debug This section tries to solve some of the problems encountered with the students during the lab Nothing appears in minicom Make sure you are using the Raspberry Pi OS Bookworm image from Lab 1 on the sd card Make sure there is the line enable_uart=1 at the end of the /boot/config.txt of your Raspberry Pi OS image The sd-card must be plugged in the RPI in the sd port, not with a usb adapter Make sure you are in the dialout group in the terminal from which you launch minicom Before starting minicom, check using the following command : groups If dialout doesn't appear, refer to the Enable serial interface and login shell over serial in A. Writing the Raspberry Pi OS image on the sd-card section to solve this. Make sure the wiring is correct. In UART, Rx goes on Tx and Tx on Rx. If nothing of these solves the issue, the cause is probably hardware either from your computer (ex: failing usb port) or from the RPI setup (ex: failing FTDI USB, failing sd-card, ...) You can't access or write on the sd-card when it is plugged on your computer Try formatting the card, if you can't don't insist, the sd card is probably dead. You can't use nmcli Make sure you are using the Raspberry Pi OS Bookworm (or newer) image from Lab 1 on the sd card Older versions of Raspberry Pi OS don't use nmcli but /etc/wpa_supplicant.conf and /etc/dhcpch.conf files.","title":"Debug"},{"location":"image/lab3/debug/#debug","text":"This section tries to solve some of the problems encountered with the students during the lab","title":"Debug"},{"location":"image/lab3/debug/#nothing-appears-in-minicom","text":"Make sure you are using the Raspberry Pi OS Bookworm image from Lab 1 on the sd card Make sure there is the line enable_uart=1 at the end of the /boot/config.txt of your Raspberry Pi OS image The sd-card must be plugged in the RPI in the sd port, not with a usb adapter Make sure you are in the dialout group in the terminal from which you launch minicom Before starting minicom, check using the following command : groups If dialout doesn't appear, refer to the Enable serial interface and login shell over serial in A. Writing the Raspberry Pi OS image on the sd-card section to solve this. Make sure the wiring is correct. In UART, Rx goes on Tx and Tx on Rx. If nothing of these solves the issue, the cause is probably hardware either from your computer (ex: failing usb port) or from the RPI setup (ex: failing FTDI USB, failing sd-card, ...)","title":"Nothing appears in minicom"},{"location":"image/lab3/debug/#you-cant-access-or-write-on-the-sd-card-when-it-is-plugged-on-your-computer","text":"Try formatting the card, if you can't don't insist, the sd card is probably dead.","title":"You can't access or write on the sd-card when it is plugged on your computer"},{"location":"image/lab3/debug/#you-cant-use-nmcli","text":"Make sure you are using the Raspberry Pi OS Bookworm (or newer) image from Lab 1 on the sd card Older versions of Raspberry Pi OS don't use nmcli but /etc/wpa_supplicant.conf and /etc/dhcpch.conf files.","title":"You can't use nmcli"},{"location":"image/lab3/intro/","text":"Lab 3 - Introduction Objectives Setting-up and working with the Raspberry Pi OS without graphical user interface Using the Raspberry Pi OS image configured in the previous labs Creating the sd-card with the image No network ? Don\u2019t worry , connect a console ... Setting up the network (Wi-Fi and Ethernet) Setting up ssh Required materials Raspberry Pi 3 Model B Raspberry Pi power supply FTDI USB cable Sd-card Sd-card adapter References https://www.raspberrypi.com/documentation/computers https://learn.sparkfun.com/tutorials/headless-raspberry-pi-setup https://apical.xyz/fiches/l_unite_centrale_du_systeme_domotique_002/configurer_le_reseau_wi-fi_sur_le_raspberry_pi","title":"Lab 3 - Introduction"},{"location":"image/lab3/intro/#lab-3-introduction","text":"","title":"Lab 3 - Introduction"},{"location":"image/lab3/intro/#objectives","text":"Setting-up and working with the Raspberry Pi OS without graphical user interface Using the Raspberry Pi OS image configured in the previous labs Creating the sd-card with the image No network ? Don\u2019t worry , connect a console ... Setting up the network (Wi-Fi and Ethernet) Setting up ssh","title":"Objectives"},{"location":"image/lab3/intro/#required-materials","text":"Raspberry Pi 3 Model B Raspberry Pi power supply FTDI USB cable Sd-card Sd-card adapter","title":"Required materials"},{"location":"image/lab3/intro/#references","text":"https://www.raspberrypi.com/documentation/computers https://learn.sparkfun.com/tutorials/headless-raspberry-pi-setup https://apical.xyz/fiches/l_unite_centrale_du_systeme_domotique_002/configurer_le_reseau_wi-fi_sur_le_raspberry_pi","title":"References"},{"location":"image/lab3/saving/","text":"D. Cloning the image (not working ...) To save all the changes made on the Raspberry PI image, we can clone the image from the sd-card After stopping the RPI (unplug the power supply) , we remove the sd-card and mount it on the computer With dd The sd-card may be larger than the Raspberry OS image (for example 32 Gb sd-card for our image of 4 Gb). If the partition /dev/sd?2 is very large with lot of empty space, gparted command can be used to shrink it before doing dd : sudo gparted /dev/sd?2 Then resize the image to the minimum size + few space We use the fdisk command to get the actual size of the image. Replace ? in /dev/sd? with the right letter: sudo fdisk -l /dev/sd? The number of blocks is given is the \u201dEnd\u201d value for \u201d/dev/sd?2\u201d (ex 8724479). We use this count in the dd command to copy back the modifed Raspberry OS image on our computer. copy the image from the sd-card to the computer : replace ? with the appropriate drive letter Warning When using the dd command make sure you don't overwrite the wrong partitions or you will get big trouble sudo dd if = /dev/sdb of = imgs/2024-11-19-raspios-bookworm-arm64-lite-modified-2024.img count = 8724479 bs = 512 Congrats ! You ended this lab series ! You will soon use your knowledge to configure an embedded Linux for a robot.","title":"D. Cloning the image (not working ...)"},{"location":"image/lab3/saving/#d-cloning-the-image-not-working","text":"To save all the changes made on the Raspberry PI image, we can clone the image from the sd-card After stopping the RPI (unplug the power supply) , we remove the sd-card and mount it on the computer","title":"D. Cloning the image (not working ...)"},{"location":"image/lab3/saving/#with-dd","text":"The sd-card may be larger than the Raspberry OS image (for example 32 Gb sd-card for our image of 4 Gb). If the partition /dev/sd?2 is very large with lot of empty space, gparted command can be used to shrink it before doing dd : sudo gparted /dev/sd?2 Then resize the image to the minimum size + few space We use the fdisk command to get the actual size of the image. Replace ? in /dev/sd? with the right letter: sudo fdisk -l /dev/sd? The number of blocks is given is the \u201dEnd\u201d value for \u201d/dev/sd?2\u201d (ex 8724479). We use this count in the dd command to copy back the modifed Raspberry OS image on our computer. copy the image from the sd-card to the computer : replace ? with the appropriate drive letter Warning When using the dd command make sure you don't overwrite the wrong partitions or you will get big trouble sudo dd if = /dev/sdb of = imgs/2024-11-19-raspios-bookworm-arm64-lite-modified-2024.img count = 8724479 bs = 512 Congrats ! You ended this lab series ! You will soon use your knowledge to configure an embedded Linux for a robot.","title":"With dd"},{"location":"image/lab3/setting/","text":"C. Setting up network for ssh access Recap : 4 ways to access the RPI without network We have now 4 ways to setup the RPI image without network, for example to set the network parameters. Note that all these 4 ways do not require the use of a display connected on the HDMI plug and mouse+keyboard connected on the USB plugs of the RPI BOARD mount the RPI image (raspios bookworm) on host as a standard file system to modify configuration files chroot on the RPI sd-card image on host to directly execute RPI configuration commands on host QEMU virtual machine running the RPI image from the sd-card RPI console (terminal) on the actual RPI board via the FTDI USB cable, accessed with minicom (or similar tools) on the host If you do not want to use the serial terminal or want to be able to log in to your Raspberry Pi over a network connection, you can give your Pi a static IP address, connect it to your network (or to your computer via a crossover/Ethernet cable), and log in via SSH. We will now setup the network on the RPI The simplest way is using the 4th method: the RPI console(terminal) via the FTDI USB cable and minicom, because we can use the real board and raspi-config . Note Windows and Mac cannot natively access the filesystem partition of the Raspberry Pi image on the SD card because its format is ext4 , the native Linux filesystem format. As a result, the easiest solutions are to access a computer with a Linux operating system or to use the 4th method (which is our case now). Configure the network interfaces We are still connected to the RPI board via serial Enable Wifi To list all the network interfaces, we use the ifconfig command. There should be 3 interfaces : lo: local interface (no physical network) eth0: ethernet RJ45 wired network wlan0: Wi-Fi wireless (radio) network If wlan0 is not listed, as it is the case on a fresh install, you must specify the country where you use your device. This allows your device to choose the correct frequency bands for 5 GHz networking. We need to set the Wi-Fi country to FR. Use raspi-config to set WLAN country to France Configure a Wifi interface Since Raspberry Pi OS Bookworm (2023), the network is managed by NetworkManager, while on previous versions it was managed by dhcpcd. Note On versions older than Bookworm, there are 2 files to modify : /etc/wpa_supplicant/wpa_supplicant.conf : to set the Wi-Fi /etc/dhcpcd.conf : to set the IP addresses. Follow this tutorial if you need to do so : https://learn.sparkfun.com/tutorials/headless-raspberry-pi-setup A static IP address wil be use to simplify the access to the RPI via ssh. Both ethernet and Wi-Fi interfaces will be defined, each with a different IP address. Note For each network interface, a file will be created in /etc/NetworkManager/system-connections We configure the network with NetworkManager using the nmcli (Network Manager Command Line Interface) command tool. 1 - Issue Configure the Wifi connection to the iot (password: enstaL@b) network using nmcli Help on https://www.raspberrypi.com/documentation/computers/configuration.html#wireless-networking-command-line 1 - Solution sudo nmcli --ask dev wifi connect iot Enter password Now check a file has been created for your wifi interface in /etc/NetworkManager/system-connections ls /etc/NetworkManager/system-connections Have a look to the created file. It should look like this : [ connection ] id = iot uuid = 74a90378-23c2-493e-a524-138a17c10184 type = wifi interface-name = wlan0 [ wifi ] mode = infrastructure ssid = iot [ wifi-security ] auth-alg = open key-mgmt = wpa-psk psk = enstaL@b [ ipv4 ] method = auto [ ipv6 ] addr-gen-mode = default method = auto [ proxy ] Tip If we can't access the real board and we want to setup the network on the Raspberry Pi OS image from our computer, we would have to create and configure this file manually because nmcli doesn't work with chroot. It is possible to encrypt the password using the wpa_passphrase tool for security reasons but this is optional. wpa_passphrase <network_ssid> <password> This will return an encrypted password. Copy it in your wifi interface configuration file instead of the real password The iot network has internet connection, so you can try sudo apt update for example. Configure an ethernet interface We may want to use a ethernet cable to connect to the RPI (for example to get a higher data rate than via Wifi), in this case we can set eth0. First, find the ethernet connection name (probably something like Wired connection 1 or eth0 ): nmcli connection show sudo nmcli connection modify \"Wired connection 1\" \\ ipv4.method manual \\ ipv4.addresses 192 .168.1.10/24 \\ ipv4.gateway \"192.168.1.1\" \\ ipv4.dns \"172.0.0.35 172.0.0.37 8.8.8.8 8.8.4.4\" Apply the change : sudo nmcli connection down \"Wired connection 1\" sudo nmcli connection up \"Wired connection 1\" Trying to find the IP address of the RPI From the host via network In this case, suppose we don't have a FTDI USB cable and we configured the network interfaces on the RPI OS image on host We need to proceed to a systematic search over all the network of your hostname (the name you have given earlier in Lab 1). Note Can take a very long time with 16 bits masks. Faster, around one minute, with 24 bits masks. On host, we can scan all devices on the iot network, this takes quite a long time (1 minute or more). The iot network's ip address is 172.19.144.0 Be carefull, on iot the network mask is 255.255.252.0 or /22 2 - Issue Scan the iot network using nmap . Do this before and after booting up the raspberry pi, and find its ip address. Tip Find the correct option to do a Nmap Ping Scan , which is a lot quicker than using nmap without option. 2 - Solution nmap -sP 172 .19.144.0/22 With the console (via minicom) Note This second option is easier but we need a serial connection to the real board, so more hardware Simply show network configuration using ifconfig and look for inet. Enable ssh The RPI image (even the lite one) has all softwares installed to access it via ssh. However, port 22 is not accessible by default ! Try from host : ssh ue41@<ip_addr> The permission is denied ! Enable ssh on the RPI board using : sudo systemctl enable ssh Then start the service : sudo systemctl start ssh Check it is working : systemctl status ssh Note We can also do it with raspi-config Tip When preparing the OS image on host or on the sd-card we would simply create a ssh file in the boot folder. When booting the real board with this image, a first-boot service checks for /boot/ssh, and enable ssh if it finds it. It only works on first boot ! If you have already booted the board once with your image on your sd-card but you haven't created the /boot/ssh file before and you can't access the real board via serial, this method won't work. Instead : Either use chroot on the sd-card and type : sudo systemctl enable ssh Either create the /boot/ssh file on your local OS image and write it again on the sd-card Now try again : ssh ue41@<ip_addr> You should now be able to connect via ssh ! You finished the setup ! Congrats ! You ended this lab series ! You will soon use your knowledge to configure an embedded Linux for a robot.","title":"C. Setting up network for ssh access"},{"location":"image/lab3/setting/#c-setting-up-network-for-ssh-access","text":"","title":"C. Setting up network for ssh access"},{"location":"image/lab3/setting/#recap-4-ways-to-access-the-rpi-without-network","text":"We have now 4 ways to setup the RPI image without network, for example to set the network parameters. Note that all these 4 ways do not require the use of a display connected on the HDMI plug and mouse+keyboard connected on the USB plugs of the RPI BOARD mount the RPI image (raspios bookworm) on host as a standard file system to modify configuration files chroot on the RPI sd-card image on host to directly execute RPI configuration commands on host QEMU virtual machine running the RPI image from the sd-card RPI console (terminal) on the actual RPI board via the FTDI USB cable, accessed with minicom (or similar tools) on the host If you do not want to use the serial terminal or want to be able to log in to your Raspberry Pi over a network connection, you can give your Pi a static IP address, connect it to your network (or to your computer via a crossover/Ethernet cable), and log in via SSH. We will now setup the network on the RPI The simplest way is using the 4th method: the RPI console(terminal) via the FTDI USB cable and minicom, because we can use the real board and raspi-config . Note Windows and Mac cannot natively access the filesystem partition of the Raspberry Pi image on the SD card because its format is ext4 , the native Linux filesystem format. As a result, the easiest solutions are to access a computer with a Linux operating system or to use the 4th method (which is our case now).","title":"Recap : 4 ways to access the RPI without network"},{"location":"image/lab3/setting/#configure-the-network-interfaces","text":"We are still connected to the RPI board via serial","title":"Configure the network interfaces"},{"location":"image/lab3/setting/#enable-wifi","text":"To list all the network interfaces, we use the ifconfig command. There should be 3 interfaces : lo: local interface (no physical network) eth0: ethernet RJ45 wired network wlan0: Wi-Fi wireless (radio) network If wlan0 is not listed, as it is the case on a fresh install, you must specify the country where you use your device. This allows your device to choose the correct frequency bands for 5 GHz networking. We need to set the Wi-Fi country to FR. Use raspi-config to set WLAN country to France","title":"Enable Wifi"},{"location":"image/lab3/setting/#configure-a-wifi-interface","text":"Since Raspberry Pi OS Bookworm (2023), the network is managed by NetworkManager, while on previous versions it was managed by dhcpcd. Note On versions older than Bookworm, there are 2 files to modify : /etc/wpa_supplicant/wpa_supplicant.conf : to set the Wi-Fi /etc/dhcpcd.conf : to set the IP addresses. Follow this tutorial if you need to do so : https://learn.sparkfun.com/tutorials/headless-raspberry-pi-setup A static IP address wil be use to simplify the access to the RPI via ssh. Both ethernet and Wi-Fi interfaces will be defined, each with a different IP address. Note For each network interface, a file will be created in /etc/NetworkManager/system-connections We configure the network with NetworkManager using the nmcli (Network Manager Command Line Interface) command tool. 1 - Issue Configure the Wifi connection to the iot (password: enstaL@b) network using nmcli Help on https://www.raspberrypi.com/documentation/computers/configuration.html#wireless-networking-command-line 1 - Solution sudo nmcli --ask dev wifi connect iot Enter password Now check a file has been created for your wifi interface in /etc/NetworkManager/system-connections ls /etc/NetworkManager/system-connections Have a look to the created file. It should look like this : [ connection ] id = iot uuid = 74a90378-23c2-493e-a524-138a17c10184 type = wifi interface-name = wlan0 [ wifi ] mode = infrastructure ssid = iot [ wifi-security ] auth-alg = open key-mgmt = wpa-psk psk = enstaL@b [ ipv4 ] method = auto [ ipv6 ] addr-gen-mode = default method = auto [ proxy ] Tip If we can't access the real board and we want to setup the network on the Raspberry Pi OS image from our computer, we would have to create and configure this file manually because nmcli doesn't work with chroot. It is possible to encrypt the password using the wpa_passphrase tool for security reasons but this is optional. wpa_passphrase <network_ssid> <password> This will return an encrypted password. Copy it in your wifi interface configuration file instead of the real password The iot network has internet connection, so you can try sudo apt update for example.","title":"Configure a Wifi interface"},{"location":"image/lab3/setting/#configure-an-ethernet-interface","text":"We may want to use a ethernet cable to connect to the RPI (for example to get a higher data rate than via Wifi), in this case we can set eth0. First, find the ethernet connection name (probably something like Wired connection 1 or eth0 ): nmcli connection show sudo nmcli connection modify \"Wired connection 1\" \\ ipv4.method manual \\ ipv4.addresses 192 .168.1.10/24 \\ ipv4.gateway \"192.168.1.1\" \\ ipv4.dns \"172.0.0.35 172.0.0.37 8.8.8.8 8.8.4.4\" Apply the change : sudo nmcli connection down \"Wired connection 1\" sudo nmcli connection up \"Wired connection 1\"","title":"Configure an ethernet interface"},{"location":"image/lab3/setting/#trying-to-find-the-ip-address-of-the-rpi","text":"","title":"Trying to find the IP address of the RPI"},{"location":"image/lab3/setting/#from-the-host-via-network","text":"In this case, suppose we don't have a FTDI USB cable and we configured the network interfaces on the RPI OS image on host We need to proceed to a systematic search over all the network of your hostname (the name you have given earlier in Lab 1). Note Can take a very long time with 16 bits masks. Faster, around one minute, with 24 bits masks. On host, we can scan all devices on the iot network, this takes quite a long time (1 minute or more). The iot network's ip address is 172.19.144.0 Be carefull, on iot the network mask is 255.255.252.0 or /22 2 - Issue Scan the iot network using nmap . Do this before and after booting up the raspberry pi, and find its ip address. Tip Find the correct option to do a Nmap Ping Scan , which is a lot quicker than using nmap without option. 2 - Solution nmap -sP 172 .19.144.0/22","title":"From the host via network"},{"location":"image/lab3/setting/#with-the-console-via-minicom","text":"Note This second option is easier but we need a serial connection to the real board, so more hardware Simply show network configuration using ifconfig and look for inet.","title":"With the console (via minicom)"},{"location":"image/lab3/setting/#enable-ssh","text":"The RPI image (even the lite one) has all softwares installed to access it via ssh. However, port 22 is not accessible by default ! Try from host : ssh ue41@<ip_addr> The permission is denied ! Enable ssh on the RPI board using : sudo systemctl enable ssh Then start the service : sudo systemctl start ssh Check it is working : systemctl status ssh Note We can also do it with raspi-config Tip When preparing the OS image on host or on the sd-card we would simply create a ssh file in the boot folder. When booting the real board with this image, a first-boot service checks for /boot/ssh, and enable ssh if it finds it. It only works on first boot ! If you have already booted the board once with your image on your sd-card but you haven't created the /boot/ssh file before and you can't access the real board via serial, this method won't work. Instead : Either use chroot on the sd-card and type : sudo systemctl enable ssh Either create the /boot/ssh file on your local OS image and write it again on the sd-card Now try again : ssh ue41@<ip_addr> You should now be able to connect via ssh ! You finished the setup ! Congrats ! You ended this lab series ! You will soon use your knowledge to configure an embedded Linux for a robot.","title":"Enable ssh"},{"location":"image/lab3/writing/","text":"A. Writing the Raspberry Pi OS image on the sd-card In this part, we plan to write our Raspberry Pi OS image on a sd-card in order to use it on a real board. Warning Make sure to use the Raspberry Pi OS bookworm image you set up in Lab 1 Headless Raspberry Pi For convenience or to save space and money, we don't want to use additional hardware components such as a monitor, keyboard, or mouse to access our Raspberry Pi, especially with a desktopless OS such as our Lite version of Raspberry Pi OS. We call this screenless setup a headless Raspberry Pi. There are different ways to configure a headless Raspberry Pi, here are three : Serial Terminal - This requires extra hardware in the form of a serial-to-USB adapter, but it is by far the most robust way to connect, as you are not relying on any network setup. Ethernet with Static IP Address - This method requires a Linux operating system to change some files on the Raspberry Pi image. You can give the Raspberry Pi a static IP address and then use an Ethernet cable (or WiFi) to log in. WiFi with DHCP - You will need to have access to your router to find your Raspberry Pi's IP address in order to log in via SSH. As a result, this may not be the best option in school or office environments. If you would like to access your Raspberry Pi using the least amount of software work or without network, you will need some extra hardware. Two of the pins on the Raspberry Pi offer transmit and receive data for serial communication. With a small change to a file on the boot sector of the SD card, a command line terminal will be broadcast over this serial line, and you can enter commands to control Linux, write programs, etc. If the other methods do not work to gain access to your Raspberry Pi or you lose your video out signal, using the serial terminal is a great way to see if your Raspberry Pi is still working and to debug any problems you might have. You will need a USB to serial converter for this to work. Enable serial interface and login shell over serial In versions of the Raspberry Pi after 3 (e.g. 3 Model B, 3 Model B+, Zero W), the processor contains two hardware UARTs. One is dedicated to the Bluetooth module, while the other is a less-featured \"mini UART.\" The serial interface is not enabled by default on the board, but we have already enabled it in Lab 1. Warning If Lab 1 made you use raspi-config to enable UART, it may have failed even if your setup was correct. In fact, raspi-config needs a real Raspberry Pi kernel to work well, and QEMU is not sufficient. But good news, most things raspi-config does are just file edits, so we can do it safely manually. We will make sure the serial interface is enabled : Mount the image using sudo losetup -P /dev/loop50 imgs/2024-11-19-raspios-bookworm-arm64-lite.img sudo mount /dev/loop50p2 /mnt/rpi sudo mount /dev/loop50p1 /mnt/rpi/boot Look for a config.txt file in /boot and open it. Now check there is the line enable_uart=1 under the [all] section, if that's not the case add it, save and exit. Unmount the image : sudo umount /mnt/rpi/boot sudo umount /mnt/rpi sudo losetup -d /dev/loop50 The sd-card can now be unmounted from your computer. Choose an Imager We need to choose an imager and download it. Raspberry Pi Imager and Balena Etcher are the go-to imagers. Raspberry Pi Imager is designed for Raspberry Pi users : Easily pick Raspberry Pi OS or other OSes from the app itself. Zero-fuss experience built specifically around Pi usage. Built-in downloads and automatic image selections. Supports writing local image files Balena Etcher offers a broad compatibility and reliability : Write any OS image (Ubuntu, Fedora, RetroPie, custom ISOs, etc.) Verification after writing to reduce corrupted cards Doesn't offer an OS selection in the app, it needs local image file As we are using a custom image, we will use Balena Etcher which is designed to work with custom images and verifies the write integrity to avoid any corruption. Note You could use Raspberry Pi Imager too as it supports writing local image files but it doesn't verify the image after writing. You would prefer using it when you want an official OS for Raspberry Pi and built-in options. Write the image Download the software from the official website: https://etcher.balena.io/ Insert the sd-card in your computer. Warning You might need to use a sd-to-usb adapter if an error occurs when writing the image Finally, launch Balena Etcher and follow the the process to write the image on the sd-card. After a few minutes, the copy should be done and the sd-card ready to be inserted in the Raspberry PI (RPI) board.","title":"A. Writing the Raspberry Pi OS image on the sd-card"},{"location":"image/lab3/writing/#a-writing-the-raspberry-pi-os-image-on-the-sd-card","text":"In this part, we plan to write our Raspberry Pi OS image on a sd-card in order to use it on a real board. Warning Make sure to use the Raspberry Pi OS bookworm image you set up in Lab 1","title":"A. Writing the Raspberry Pi OS image on the sd-card"},{"location":"image/lab3/writing/#headless-raspberry-pi","text":"For convenience or to save space and money, we don't want to use additional hardware components such as a monitor, keyboard, or mouse to access our Raspberry Pi, especially with a desktopless OS such as our Lite version of Raspberry Pi OS. We call this screenless setup a headless Raspberry Pi. There are different ways to configure a headless Raspberry Pi, here are three : Serial Terminal - This requires extra hardware in the form of a serial-to-USB adapter, but it is by far the most robust way to connect, as you are not relying on any network setup. Ethernet with Static IP Address - This method requires a Linux operating system to change some files on the Raspberry Pi image. You can give the Raspberry Pi a static IP address and then use an Ethernet cable (or WiFi) to log in. WiFi with DHCP - You will need to have access to your router to find your Raspberry Pi's IP address in order to log in via SSH. As a result, this may not be the best option in school or office environments. If you would like to access your Raspberry Pi using the least amount of software work or without network, you will need some extra hardware. Two of the pins on the Raspberry Pi offer transmit and receive data for serial communication. With a small change to a file on the boot sector of the SD card, a command line terminal will be broadcast over this serial line, and you can enter commands to control Linux, write programs, etc. If the other methods do not work to gain access to your Raspberry Pi or you lose your video out signal, using the serial terminal is a great way to see if your Raspberry Pi is still working and to debug any problems you might have. You will need a USB to serial converter for this to work.","title":"Headless Raspberry Pi"},{"location":"image/lab3/writing/#enable-serial-interface-and-login-shell-over-serial","text":"In versions of the Raspberry Pi after 3 (e.g. 3 Model B, 3 Model B+, Zero W), the processor contains two hardware UARTs. One is dedicated to the Bluetooth module, while the other is a less-featured \"mini UART.\" The serial interface is not enabled by default on the board, but we have already enabled it in Lab 1. Warning If Lab 1 made you use raspi-config to enable UART, it may have failed even if your setup was correct. In fact, raspi-config needs a real Raspberry Pi kernel to work well, and QEMU is not sufficient. But good news, most things raspi-config does are just file edits, so we can do it safely manually. We will make sure the serial interface is enabled : Mount the image using sudo losetup -P /dev/loop50 imgs/2024-11-19-raspios-bookworm-arm64-lite.img sudo mount /dev/loop50p2 /mnt/rpi sudo mount /dev/loop50p1 /mnt/rpi/boot Look for a config.txt file in /boot and open it. Now check there is the line enable_uart=1 under the [all] section, if that's not the case add it, save and exit. Unmount the image : sudo umount /mnt/rpi/boot sudo umount /mnt/rpi sudo losetup -d /dev/loop50 The sd-card can now be unmounted from your computer.","title":"Enable serial interface and login shell over serial"},{"location":"image/lab3/writing/#choose-an-imager","text":"We need to choose an imager and download it. Raspberry Pi Imager and Balena Etcher are the go-to imagers. Raspberry Pi Imager is designed for Raspberry Pi users : Easily pick Raspberry Pi OS or other OSes from the app itself. Zero-fuss experience built specifically around Pi usage. Built-in downloads and automatic image selections. Supports writing local image files Balena Etcher offers a broad compatibility and reliability : Write any OS image (Ubuntu, Fedora, RetroPie, custom ISOs, etc.) Verification after writing to reduce corrupted cards Doesn't offer an OS selection in the app, it needs local image file As we are using a custom image, we will use Balena Etcher which is designed to work with custom images and verifies the write integrity to avoid any corruption. Note You could use Raspberry Pi Imager too as it supports writing local image files but it doesn't verify the image after writing. You would prefer using it when you want an official OS for Raspberry Pi and built-in options.","title":"Choose an Imager"},{"location":"image/lab3/writing/#write-the-image","text":"Download the software from the official website: https://etcher.balena.io/ Insert the sd-card in your computer. Warning You might need to use a sd-to-usb adapter if an error occurs when writing the image Finally, launch Balena Etcher and follow the the process to write the image on the sd-card. After a few minutes, the copy should be done and the sd-card ready to be inserted in the Raspberry PI (RPI) board.","title":"Write the image"}]}