{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Embedded Systems course Definition An embedded system is a specialized computer system\u2014a combination of a computer processor, computer memory, and input/output peripheral devices\u2014that has a dedicated function within a larger mechanical or electronic system. It is embedded as part of a complete device often including electrical or electronic hardware and mechanical parts. Because an embedded system typically controls physical operations of the machine that it is embedded within, it often has real-time computing constraints. @Wikipedia Objectives The main objective of this course is to learn how to create your own embedded image of Operating System (OS) Subjects include : the configuration of the network interface of an embedded system how to test and modify the embedded OS directly on your host machine (QEMU, mounting, etc) containerization (Docker) References Most of the content of this course was written by Beno\u00eet Zerr, the previous teacher, and is based on his slides.","title":"Home"},{"location":"#welcome-to-the-embedded-systems-course","text":"","title":"Welcome to the Embedded Systems course"},{"location":"#definition","text":"An embedded system is a specialized computer system\u2014a combination of a computer processor, computer memory, and input/output peripheral devices\u2014that has a dedicated function within a larger mechanical or electronic system. It is embedded as part of a complete device often including electrical or electronic hardware and mechanical parts. Because an embedded system typically controls physical operations of the machine that it is embedded within, it often has real-time computing constraints. @Wikipedia","title":"Definition"},{"location":"#objectives","text":"The main objective of this course is to learn how to create your own embedded image of Operating System (OS) Subjects include : the configuration of the network interface of an embedded system how to test and modify the embedded OS directly on your host machine (QEMU, mounting, etc) containerization (Docker)","title":"Objectives"},{"location":"#references","text":"Most of the content of this course was written by Beno\u00eet Zerr, the previous teacher, and is based on his slides.","title":"References"},{"location":"image/qemu/","text":"Introduction to QEMU Introduction QEMU , which stands for Quick Emulator , is an open-source software project that provides an emulation and virtualization framework. It is designed to run a variety of guest operating systems on a host operating system, and can emulate a wide range of hardware platforms. QEMU has been created by Fabrice Bellard (also known for ffmpeg) QEMU can be used for a variety of purposes, including: Running legacy operating systems or software on modern hardware. Running multiple operating systems on a single host machine for testing or development purposes. Providing a safe and isolated environment for running untrusted or potentially malicious code. Developing and testing software for embedded devices or other specialized hardware platforms. Visit QEMU website to learn more How QEMU works QEMU works by emulating the hardware components of a computer, including the CPU, memory, storage devices, network adapters, and input/output devices. When a guest operating system is started, it runs on top of the emulated hardware, just as it would on a physical machine. The guest operating system sees the emulated hardware as if it were real, and interacts with it accordingly. QEMU can also provide virtualization capabilities, allowing multiple operating systems to run on a single host machine with minimal performance overhead. In this mode, QEMU uses hardware virtualization extensions (such as Intel VT-x or AMD-V) to provide isolated environments for each guest operating system. Using QEMU QEMU is a powerful and versatile tool that can be used for a variety of purposes, from running legacy software to testing new operating systems. With its ease of use and wide range of features, QEMU is a must-have tool for any system administrator or developer. Install sudo apt-get install qemu-system qemu-user-static binfmt-support","title":"Introduction to QEMU"},{"location":"image/qemu/#introduction-to-qemu","text":"","title":"Introduction to QEMU"},{"location":"image/qemu/#introduction","text":"QEMU , which stands for Quick Emulator , is an open-source software project that provides an emulation and virtualization framework. It is designed to run a variety of guest operating systems on a host operating system, and can emulate a wide range of hardware platforms. QEMU has been created by Fabrice Bellard (also known for ffmpeg) QEMU can be used for a variety of purposes, including: Running legacy operating systems or software on modern hardware. Running multiple operating systems on a single host machine for testing or development purposes. Providing a safe and isolated environment for running untrusted or potentially malicious code. Developing and testing software for embedded devices or other specialized hardware platforms. Visit QEMU website to learn more","title":"Introduction"},{"location":"image/qemu/#how-qemu-works","text":"QEMU works by emulating the hardware components of a computer, including the CPU, memory, storage devices, network adapters, and input/output devices. When a guest operating system is started, it runs on top of the emulated hardware, just as it would on a physical machine. The guest operating system sees the emulated hardware as if it were real, and interacts with it accordingly. QEMU can also provide virtualization capabilities, allowing multiple operating systems to run on a single host machine with minimal performance overhead. In this mode, QEMU uses hardware virtualization extensions (such as Intel VT-x or AMD-V) to provide isolated environments for each guest operating system.","title":"How QEMU works"},{"location":"image/qemu/#using-qemu","text":"QEMU is a powerful and versatile tool that can be used for a variety of purposes, from running legacy software to testing new operating systems. With its ease of use and wide range of features, QEMU is a must-have tool for any system administrator or developer.","title":"Using QEMU"},{"location":"image/qemu/#install","text":"sudo apt-get install qemu-system qemu-user-static binfmt-support","title":"Install"},{"location":"image/lab1/executing/","text":"E. Executing commands on the Raspberry Pi OS image Introduction Changing values in configuration files in the image on host is fairly easy (as seen before) But what about running a command in the image on host? for example to change the password ? Problem 1 Host executes X86 code while image contains ARM executables Solution : emulating ARM on X86 with QEMU (created by Fabrice Bellard) --> Read Introduction to QEMU Problem 2 Host commands are under / (ex /bin/bash) while image commands are under /mnt/rpi (ex /mnt/rpi/bin/bash). Solution : changing the root (/) using chroot, introduced in development of Version 7 Unix in 1979. Starting chroot Standard process Prepare the Raspberry Pi OS image to be executed it on host ... First we need to mount the system folder the same way they are mounted on the real Raspberry Pi board Mount the image in a loop device (we use /dev/loop50 as before) sudo losetup -P /dev/loop50 imgs/2024-11-19-raspios-bookworm-arm64-lite.img Mount the partitions (as before) sudo mount /dev/loop50p2 /mnt/rpi sudo mount /dev/loop50p1 /mnt/rpi/boot Mount the system folders to make them similar as if we were executing on the actual Raspberry board for example, /dev is an important folder that gives access to all the devices : /mnt/rpi/dev must be translated to /dev sudo mount --bind /dev /mnt/rpi/dev/ 1 - Issue Do the same for all the other system folders we need : /sys , which is an interface to the kernel /proc , which is a virtual file system working as an interface to ongoing processes 1 - Solution sudo mount --bind /sys /mnt/rpi/sys/ sudo mount --bind /proc /mnt/rpi/proc/ Note A PTY (pseudo-terminal) is a kernel feature that lets programs behave as if they are attached to a real terminal. Examples of things that require PTYs: interactive shells (bash, sh) sudo ssh su screen, tmux apt / dpkg (often indirectly) systemctl So in a chroot, no PTYs = lots of weird failures. PTYs (/dev/pts/*), pseudo-terminals are provided by the devpts filesystem. Mount it using : mkdir -p /mnt/rpi/dev/pts sudo mount -t devpts devpts /mnt/rpi/dev/pts Warning If you get a PTY error, reboot your computer and avoid the previous step Note We need to disable some specific actions done solely on the real board. The /etc/ld.so.preload file tells what libraries should be loaded before the other. This does not work on the virtual Raspberry Pi. On modern Debian-based systems (including Raspberry Pi OS Bookworm = Debian 12) : /etc/ld.so.preload is optional It is not created by default The dynamic linker only reads it if it exists The file /etc/ld.so.preload should only be executed on actual board. Check if there is such a file : ls /mnt/rpi/etc/ld.so.preload It should return nothing. If it returns /mnt/rpi/etc/ld.so.preload , it means you are using an old version, then for safety keep a backup version and comment the content of /mnt/rpi/etc/ld.so.preload . We also need to add QEMU to translate ARM code to X86 64 code so it can be executed on the host computer. QEMU is added by just copying the emulator in the Raspberry Pi OS image : sudo cp /usr/bin/qemu-arm-static /mnt/rpi/usr/bin/ Warning Make sure you installed QEMU following Introduction to QEMU instructions Using host network in chroot For some applications, we may need access to Internet. A practical example is the use of the packet manager with apt We need to copy some of the host configuration files (here /etc/resolv.conf) on the image before running chroot First save the current config as a backup sudo cp /mnt/rpi/etc/resolv.conf /mnt/rpi/etc/resolv.conf.bck Copy config from host sudo cp /etc/resolv.conf /mnt/rpi/etc/resolv.conf Now all should be prepared correctly. start_chroot.bash To avoid reapeating the previous series of commands and make more easy the use of chroot we can create a bash script to run before chroot : start_chroot.bash . Example of a starting script. Create the file start_chroot.bash in rpilab. nano start_chroot.bash And copy the following : #!/bin/bash # command parameter ($1) is the path to the RPI image file # example of use : # source start_chroot.bash imgs/2024-11-19-raspios-bookworm-arm64-lite.img sudo losetup -P /dev/loop50 $1 sudo mount /dev/loop50p2 /mnt/rpi sudo mount /dev/loop50p1 /mnt/rpi/boot sudo mount --bind /dev /mnt/rpi/dev/ sudo mount --bind /sys /mnt/rpi/sys/ sudo mount --bind /proc /mnt/rpi/proc/ sudo mount -t devpts devpts /mnt/rpi/dev/pts sudo cp /usr/bin/qemu-arm-static /mnt/rpi/usr/bin/ sudo cp /mnt/rpi/etc/resolv.conf /mnt/rpi/etc/resolv.conf.bck sudo cp /etc/resolv.conf /mnt/rpi/etc/resolv.conf Run chroot We can now chroot and run the RPI image as if it was on a actual board ! /mnt/rpi will be our new / and we execute /bin/bash to start a terminal 2 - Issue Use chroot to make /mnt/rpi the new root and start a bash terminal Tip The /bin/bash command is used to open a new bash shell 2 - Solution sudo chroot /mnt/rpi /bin/bash We have now a root prompt # and we can execute commands on the RPI image, for example : to create an new user ue41 with root privileges (sudo) set locale to en US.UTF-8 using raspi-config (5 Localisation options) set keyboard to French layout using raspi-config to enable the console with raspi-config (to access the actual RPI board without network) for future use with real board (may be done later) run apt update Tip To leave the chroot shell, use Ctrl + D Note With some experience, we can do most of the setup of the RPI image without using the actual board !!! Adding a sudo user with chroot To do this, we make sure we are in chroot (# prompt) on the Raspberry PI OS, and we will proceed in two steps : We will create a new user called ue41, password ue41. (no need to answer all the questions !!! most of them can be left empty) 3 - Issue Use adduser to create the ue41 user 3 - Solution adduser ue41 Execute visudo command to give sudo permission to the created user visudo A file should open. Add a line with ue41 user here : %sudo ALL=(ALL:ALL) ALL ue41 ALL=(ALL:ALL) ALL Then write and save (nano commands) Enabling the Serial interface and RPI console for debug The console is an easy tool for debug, it can be connected to the host via FTDI USB cable and can be accessed on Ubuntu via /dev/ttyUSB0 device. Hence, it can work even if the network is not or badly defined. To enable the console, Raspberry Pi OS offers several ways : adding the line enable_uart=1 at the end of the file /mnt/rpi/boot/config.txt with standard mount of boot partition, adding the line enable_uart=1 at the end of the file /boot/config.txt in chroot mode Warning UPDATE - After verification, the following does not work well even with QEMU. raspi-config needs a real Raspberry Pi kernel, so it works only on a real board To avoid any unexpected behaviour, we will prefer manual configuration (see after this warning) As we have started chroot, we will use the raspi-config tool. Simply execute raspi-config under chroot prompt # raspi-config Then go in Interface Options and enable Serial Port . More details on raspi-config Documetation Note raspi-config can be used to easily configure a lot of features such as the network, the locale language, etc As we have started chroot, we will directly modify the /boot/config.txt file. Add the line enable_uart=1 in /boot/config.txt using nano. Clean termination of chroot Standard process To exit chroot, just type ctrl+D or exit . To return to a standard host configuration we have to : go back to the original network config if we used the host's uncomment actions in /mnt/rpi/etc/ld.so.preload if we did so unmount all the RPI image system folders stop the loop device with RPI image Restore the network config sudo cp /mnt/rpi/etc/resolv.conf.bck /mnt/rpi/etc/resolv.conf Unmount all volumes at once sudo umount /mnt/rpi/ { dev/pts,dev,sys,proc,boot, } Stop the loop device with RPI image sudo losetup -d /dev/loop50 stop_chroot.bash Just like we did for starting chroot we can create a bash script to run after chroot: stop_chroot.bash 4 - Issue Write a stop_chroot.bash script to cleanly return to the standard host configuration. 4 - Solution Create the file stop_chroot.bash . nano stop_chroot.bash And copy the following : #!/bin/bash # usage : # source stop_chroot.bash sudo cp /mnt/rpi/etc/resolv.conf.bck /mnt/rpi/etc/resolv.conf sudo umount /mnt/rpi/ { dev/pts,dev,sys,proc,boot, } sudo losetup -d /dev/loop50 Run apt command in chroot Now with the scripts you should be able to only use the following : source start_chroot.bash imgs/2024-11-19-raspios-bookworm-arm64-lite.img sudo chroot /mnt/rpi /bin/bash apt update # type ctrl-D to exit chroot source stop_chroot.bash Congrats ! You successfully ended this lab ! Keep your modified image on your computer as it will be used in a next lab.","title":"E. Executing commands on the Raspberry Pi OS image"},{"location":"image/lab1/executing/#e-executing-commands-on-the-raspberry-pi-os-image","text":"","title":"E. Executing commands on the Raspberry Pi OS image"},{"location":"image/lab1/executing/#introduction","text":"Changing values in configuration files in the image on host is fairly easy (as seen before) But what about running a command in the image on host? for example to change the password ? Problem 1 Host executes X86 code while image contains ARM executables Solution : emulating ARM on X86 with QEMU (created by Fabrice Bellard) --> Read Introduction to QEMU Problem 2 Host commands are under / (ex /bin/bash) while image commands are under /mnt/rpi (ex /mnt/rpi/bin/bash). Solution : changing the root (/) using chroot, introduced in development of Version 7 Unix in 1979.","title":"Introduction"},{"location":"image/lab1/executing/#starting-chroot","text":"","title":"Starting chroot"},{"location":"image/lab1/executing/#standard-process","text":"Prepare the Raspberry Pi OS image to be executed it on host ... First we need to mount the system folder the same way they are mounted on the real Raspberry Pi board Mount the image in a loop device (we use /dev/loop50 as before) sudo losetup -P /dev/loop50 imgs/2024-11-19-raspios-bookworm-arm64-lite.img Mount the partitions (as before) sudo mount /dev/loop50p2 /mnt/rpi sudo mount /dev/loop50p1 /mnt/rpi/boot Mount the system folders to make them similar as if we were executing on the actual Raspberry board for example, /dev is an important folder that gives access to all the devices : /mnt/rpi/dev must be translated to /dev sudo mount --bind /dev /mnt/rpi/dev/ 1 - Issue Do the same for all the other system folders we need : /sys , which is an interface to the kernel /proc , which is a virtual file system working as an interface to ongoing processes 1 - Solution sudo mount --bind /sys /mnt/rpi/sys/ sudo mount --bind /proc /mnt/rpi/proc/ Note A PTY (pseudo-terminal) is a kernel feature that lets programs behave as if they are attached to a real terminal. Examples of things that require PTYs: interactive shells (bash, sh) sudo ssh su screen, tmux apt / dpkg (often indirectly) systemctl So in a chroot, no PTYs = lots of weird failures. PTYs (/dev/pts/*), pseudo-terminals are provided by the devpts filesystem. Mount it using : mkdir -p /mnt/rpi/dev/pts sudo mount -t devpts devpts /mnt/rpi/dev/pts Warning If you get a PTY error, reboot your computer and avoid the previous step Note We need to disable some specific actions done solely on the real board. The /etc/ld.so.preload file tells what libraries should be loaded before the other. This does not work on the virtual Raspberry Pi. On modern Debian-based systems (including Raspberry Pi OS Bookworm = Debian 12) : /etc/ld.so.preload is optional It is not created by default The dynamic linker only reads it if it exists The file /etc/ld.so.preload should only be executed on actual board. Check if there is such a file : ls /mnt/rpi/etc/ld.so.preload It should return nothing. If it returns /mnt/rpi/etc/ld.so.preload , it means you are using an old version, then for safety keep a backup version and comment the content of /mnt/rpi/etc/ld.so.preload . We also need to add QEMU to translate ARM code to X86 64 code so it can be executed on the host computer. QEMU is added by just copying the emulator in the Raspberry Pi OS image : sudo cp /usr/bin/qemu-arm-static /mnt/rpi/usr/bin/ Warning Make sure you installed QEMU following Introduction to QEMU instructions","title":"Standard process"},{"location":"image/lab1/executing/#using-host-network-in-chroot","text":"For some applications, we may need access to Internet. A practical example is the use of the packet manager with apt We need to copy some of the host configuration files (here /etc/resolv.conf) on the image before running chroot First save the current config as a backup sudo cp /mnt/rpi/etc/resolv.conf /mnt/rpi/etc/resolv.conf.bck Copy config from host sudo cp /etc/resolv.conf /mnt/rpi/etc/resolv.conf Now all should be prepared correctly.","title":"Using host network in chroot"},{"location":"image/lab1/executing/#start_chrootbash","text":"To avoid reapeating the previous series of commands and make more easy the use of chroot we can create a bash script to run before chroot : start_chroot.bash . Example of a starting script. Create the file start_chroot.bash in rpilab. nano start_chroot.bash And copy the following : #!/bin/bash # command parameter ($1) is the path to the RPI image file # example of use : # source start_chroot.bash imgs/2024-11-19-raspios-bookworm-arm64-lite.img sudo losetup -P /dev/loop50 $1 sudo mount /dev/loop50p2 /mnt/rpi sudo mount /dev/loop50p1 /mnt/rpi/boot sudo mount --bind /dev /mnt/rpi/dev/ sudo mount --bind /sys /mnt/rpi/sys/ sudo mount --bind /proc /mnt/rpi/proc/ sudo mount -t devpts devpts /mnt/rpi/dev/pts sudo cp /usr/bin/qemu-arm-static /mnt/rpi/usr/bin/ sudo cp /mnt/rpi/etc/resolv.conf /mnt/rpi/etc/resolv.conf.bck sudo cp /etc/resolv.conf /mnt/rpi/etc/resolv.conf","title":"start_chroot.bash"},{"location":"image/lab1/executing/#run-chroot","text":"We can now chroot and run the RPI image as if it was on a actual board ! /mnt/rpi will be our new / and we execute /bin/bash to start a terminal 2 - Issue Use chroot to make /mnt/rpi the new root and start a bash terminal Tip The /bin/bash command is used to open a new bash shell 2 - Solution sudo chroot /mnt/rpi /bin/bash We have now a root prompt # and we can execute commands on the RPI image, for example : to create an new user ue41 with root privileges (sudo) set locale to en US.UTF-8 using raspi-config (5 Localisation options) set keyboard to French layout using raspi-config to enable the console with raspi-config (to access the actual RPI board without network) for future use with real board (may be done later) run apt update Tip To leave the chroot shell, use Ctrl + D Note With some experience, we can do most of the setup of the RPI image without using the actual board !!!","title":"Run chroot"},{"location":"image/lab1/executing/#adding-a-sudo-user-with-chroot","text":"To do this, we make sure we are in chroot (# prompt) on the Raspberry PI OS, and we will proceed in two steps : We will create a new user called ue41, password ue41. (no need to answer all the questions !!! most of them can be left empty) 3 - Issue Use adduser to create the ue41 user 3 - Solution adduser ue41 Execute visudo command to give sudo permission to the created user visudo A file should open. Add a line with ue41 user here : %sudo ALL=(ALL:ALL) ALL ue41 ALL=(ALL:ALL) ALL Then write and save (nano commands)","title":"Adding a sudo user with chroot"},{"location":"image/lab1/executing/#enabling-the-serial-interface-and-rpi-console-for-debug","text":"The console is an easy tool for debug, it can be connected to the host via FTDI USB cable and can be accessed on Ubuntu via /dev/ttyUSB0 device. Hence, it can work even if the network is not or badly defined. To enable the console, Raspberry Pi OS offers several ways : adding the line enable_uart=1 at the end of the file /mnt/rpi/boot/config.txt with standard mount of boot partition, adding the line enable_uart=1 at the end of the file /boot/config.txt in chroot mode Warning UPDATE - After verification, the following does not work well even with QEMU. raspi-config needs a real Raspberry Pi kernel, so it works only on a real board To avoid any unexpected behaviour, we will prefer manual configuration (see after this warning) As we have started chroot, we will use the raspi-config tool. Simply execute raspi-config under chroot prompt # raspi-config Then go in Interface Options and enable Serial Port . More details on raspi-config Documetation Note raspi-config can be used to easily configure a lot of features such as the network, the locale language, etc As we have started chroot, we will directly modify the /boot/config.txt file. Add the line enable_uart=1 in /boot/config.txt using nano.","title":"Enabling the Serial interface and RPI console for debug"},{"location":"image/lab1/executing/#clean-termination-of-chroot","text":"","title":"Clean termination of chroot"},{"location":"image/lab1/executing/#standard-process_1","text":"To exit chroot, just type ctrl+D or exit . To return to a standard host configuration we have to : go back to the original network config if we used the host's uncomment actions in /mnt/rpi/etc/ld.so.preload if we did so unmount all the RPI image system folders stop the loop device with RPI image Restore the network config sudo cp /mnt/rpi/etc/resolv.conf.bck /mnt/rpi/etc/resolv.conf Unmount all volumes at once sudo umount /mnt/rpi/ { dev/pts,dev,sys,proc,boot, } Stop the loop device with RPI image sudo losetup -d /dev/loop50","title":"Standard process"},{"location":"image/lab1/executing/#stop_chrootbash","text":"Just like we did for starting chroot we can create a bash script to run after chroot: stop_chroot.bash 4 - Issue Write a stop_chroot.bash script to cleanly return to the standard host configuration. 4 - Solution Create the file stop_chroot.bash . nano stop_chroot.bash And copy the following : #!/bin/bash # usage : # source stop_chroot.bash sudo cp /mnt/rpi/etc/resolv.conf.bck /mnt/rpi/etc/resolv.conf sudo umount /mnt/rpi/ { dev/pts,dev,sys,proc,boot, } sudo losetup -d /dev/loop50","title":"stop_chroot.bash"},{"location":"image/lab1/executing/#run-apt-command-in-chroot","text":"Now with the scripts you should be able to only use the following : source start_chroot.bash imgs/2024-11-19-raspios-bookworm-arm64-lite.img sudo chroot /mnt/rpi /bin/bash apt update # type ctrl-D to exit chroot source stop_chroot.bash Congrats ! You successfully ended this lab ! Keep your modified image on your computer as it will be used in a next lab.","title":"Run apt command in chroot"},{"location":"image/lab1/getting/","text":"A. Getting the Raspberry Pi OS image Create the working directory mkdir rpilab && cd rpilab Create a folder for the images mkdir imgs && cd imgs Let's choose the \"lite\" version of raspios bookworm (from 2024, November 19th) 1 - Issue Download the image in the lab from the official website: https://www.raspberrypi.com/software/operating-systems/ Click on \"View archive\" to get this version and download it using the wget command. 1 - Solution wget https://downloads.raspberrypi.com/raspios_lite_arm64/images/raspios_lite_arm64-2024-11-19/2024-11-19-raspios-bookworm-arm64-lite.img.xz Now, we want to check the checksum to ensure data integrity and avoid any problem during the download 2 - Issue Download the cheksum file ( .sha256 file) using wget Compute the checksum using the sha256sum command Verify that the resulting code is the same as the one contained in the .sha256 file, using cat to display the file's content in the shell 2 - Solution First, we download the checksum file wget https://downloads.raspberrypi.com/raspios_lite_arm64/images/raspios_lite_arm64-2024-11-19/2024-11-19-raspios-bookworm-arm64-lite.img.xz.sha256 Then, we compute the checksum sha256sum 2024 -11-19-raspios-bookworm-arm64-lite.img.xz Finally, we check that the code is the same cat 2024 -11-19-raspios-bookworm-arm64-lite.img.xz.sha256 3 - Issue We can now safely decrompress the image using xz . 3 - Solution xz -d 2024 -11-19-raspios-bookworm-arm64-lite.img.xz We go back in the lab folder cd ..","title":"A. Getting the Raspberry Pi OS image"},{"location":"image/lab1/getting/#a-getting-the-raspberry-pi-os-image","text":"Create the working directory mkdir rpilab && cd rpilab Create a folder for the images mkdir imgs && cd imgs Let's choose the \"lite\" version of raspios bookworm (from 2024, November 19th) 1 - Issue Download the image in the lab from the official website: https://www.raspberrypi.com/software/operating-systems/ Click on \"View archive\" to get this version and download it using the wget command. 1 - Solution wget https://downloads.raspberrypi.com/raspios_lite_arm64/images/raspios_lite_arm64-2024-11-19/2024-11-19-raspios-bookworm-arm64-lite.img.xz Now, we want to check the checksum to ensure data integrity and avoid any problem during the download 2 - Issue Download the cheksum file ( .sha256 file) using wget Compute the checksum using the sha256sum command Verify that the resulting code is the same as the one contained in the .sha256 file, using cat to display the file's content in the shell 2 - Solution First, we download the checksum file wget https://downloads.raspberrypi.com/raspios_lite_arm64/images/raspios_lite_arm64-2024-11-19/2024-11-19-raspios-bookworm-arm64-lite.img.xz.sha256 Then, we compute the checksum sha256sum 2024 -11-19-raspios-bookworm-arm64-lite.img.xz Finally, we check that the code is the same cat 2024 -11-19-raspios-bookworm-arm64-lite.img.xz.sha256 3 - Issue We can now safely decrompress the image using xz . 3 - Solution xz -d 2024 -11-19-raspios-bookworm-arm64-lite.img.xz We go back in the lab folder cd ..","title":"A. Getting the Raspberry Pi OS image"},{"location":"image/lab1/increasing/","text":"C. Increasing size of Raspberry Pi OS image Suppose that we are in the rpilab folder, go to imgs subfolder : cd imgs Extend partition 2 (rootfs) with 2 GB (choose one of the two methods) method 1 truncate --size = +2G 2024 -11-19-raspios-bookworm-arm64-lite.img method 2 dd if = /dev/zero bs = 1M count = 2048 >> 2024 -11-19-raspios-bookworm-arm64-lite.img Check that partition 2 has not been resized yet sudo fdisk -l 2024 -11-19-raspios-bookworm-arm64-lite.img Then, use parted to actually extend the partition 2 sudo parted 2024 -11-19-raspios-bookworm-arm64-lite.img On the command prompt,type: p resizepart 2 -1 p q Mount the image in a loop device (we use /dev/loop50 as before) sudo losetup -P /dev/loop50 2024 -11-19-raspios-bookworm-arm64-lite.img Check file system and extend file system to fully fill partition 2 sudo e2fsck -f /dev/loop50p2 sudo resize2fs /dev/loop50p2 Detach cleanly sudo losetup -d /dev/loop50 back to rpilab folder cd ..","title":"C. Increasing size of Raspberry Pi OS image"},{"location":"image/lab1/increasing/#c-increasing-size-of-raspberry-pi-os-image","text":"Suppose that we are in the rpilab folder, go to imgs subfolder : cd imgs Extend partition 2 (rootfs) with 2 GB (choose one of the two methods) method 1 truncate --size = +2G 2024 -11-19-raspios-bookworm-arm64-lite.img method 2 dd if = /dev/zero bs = 1M count = 2048 >> 2024 -11-19-raspios-bookworm-arm64-lite.img Check that partition 2 has not been resized yet sudo fdisk -l 2024 -11-19-raspios-bookworm-arm64-lite.img Then, use parted to actually extend the partition 2 sudo parted 2024 -11-19-raspios-bookworm-arm64-lite.img On the command prompt,type: p resizepart 2 -1 p q Mount the image in a loop device (we use /dev/loop50 as before) sudo losetup -P /dev/loop50 2024 -11-19-raspios-bookworm-arm64-lite.img Check file system and extend file system to fully fill partition 2 sudo e2fsck -f /dev/loop50p2 sudo resize2fs /dev/loop50p2 Detach cleanly sudo losetup -d /dev/loop50 back to rpilab folder cd ..","title":"C. Increasing size of Raspberry Pi OS image"},{"location":"image/lab1/intro/","text":"Lab 1 - Introduction Objectives Setting-up Raspberry Pi OS Image Getting the Raspberry Pi OS (formerly Raspbian) image Modifying the image on the host OS (ex. increasing size, changing settings) Executing commands on the image on the host computer (ex. adding a sudo user, raspi-config) Note The host or the host computer is the physical machine on which you will execute the Raspberry Pi OS. In this lab it is your laptop. Raspberry Pi 3B Overview : The Raspberry Pi is a small single-board computer developed in the UK by the Raspberry Pi Foundation. The Raspberry Pi 3 Model B is one of the most popular versions. It offers a low-cost, compact solution for various computing projects. Specifications : CPU: Quad-core 1.2GHz Broadcom BCM2837 64-bit ARM Cortex-A53 processor RAM: 1GB LPDDR2 Connectivity: 4 USB 2.0 ports 1 HDMI port 1 Ethernet port 3.5mm audio jack Wi-Fi 802.11n and Bluetooth 4.1 GPIO: 40-pin GPIO header Applications : Home automation Robotics IoT projects Media center Education Retro gaming console Linux on RPI Very basic behavior description : Linux comes as an image file (Raspberry Pi OS, Ubuntu, Fedora, Manjaro ARM, ...) We will use the official image Raspberry Pi OS On real boards, the image is written on a SD-CARD The Raspberry Pi OS image contains 2 partitions : boot and rootfs The boot partition contains all the important elements for starting linux : boot loader (bootcode.bin), Device Tree Blob (.dtb) , kernel (kernelx.img), starting command (cmdline.txt) , configuration (config.txt) ... The rootfs partition contains file system : /etc /lib /usr/lib, /bin /dev /opt /home ... Lab presentation In this lab you are asked to follow given instructions. Sometimes, you will meet issues you need to solve. There are tips to help you. The solutions will be displayed after the class.","title":"Lab 1 - Introduction"},{"location":"image/lab1/intro/#lab-1-introduction","text":"","title":"Lab 1 - Introduction"},{"location":"image/lab1/intro/#objectives","text":"Setting-up Raspberry Pi OS Image Getting the Raspberry Pi OS (formerly Raspbian) image Modifying the image on the host OS (ex. increasing size, changing settings) Executing commands on the image on the host computer (ex. adding a sudo user, raspi-config) Note The host or the host computer is the physical machine on which you will execute the Raspberry Pi OS. In this lab it is your laptop.","title":"Objectives"},{"location":"image/lab1/intro/#raspberry-pi-3b","text":"Overview : The Raspberry Pi is a small single-board computer developed in the UK by the Raspberry Pi Foundation. The Raspberry Pi 3 Model B is one of the most popular versions. It offers a low-cost, compact solution for various computing projects. Specifications : CPU: Quad-core 1.2GHz Broadcom BCM2837 64-bit ARM Cortex-A53 processor RAM: 1GB LPDDR2 Connectivity: 4 USB 2.0 ports 1 HDMI port 1 Ethernet port 3.5mm audio jack Wi-Fi 802.11n and Bluetooth 4.1 GPIO: 40-pin GPIO header Applications : Home automation Robotics IoT projects Media center Education Retro gaming console","title":"Raspberry Pi 3B"},{"location":"image/lab1/intro/#linux-on-rpi","text":"Very basic behavior description : Linux comes as an image file (Raspberry Pi OS, Ubuntu, Fedora, Manjaro ARM, ...) We will use the official image Raspberry Pi OS On real boards, the image is written on a SD-CARD The Raspberry Pi OS image contains 2 partitions : boot and rootfs The boot partition contains all the important elements for starting linux : boot loader (bootcode.bin), Device Tree Blob (.dtb) , kernel (kernelx.img), starting command (cmdline.txt) , configuration (config.txt) ... The rootfs partition contains file system : /etc /lib /usr/lib, /bin /dev /opt /home ...","title":"Linux on RPI"},{"location":"image/lab1/intro/#lab-presentation","text":"In this lab you are asked to follow given instructions. Sometimes, you will meet issues you need to solve. There are tips to help you. The solutions will be displayed after the class.","title":"Lab presentation"},{"location":"image/lab1/modifying/","text":"D. Modifying the Raspberry Pi OS image 1 - Issue First mount the image's root file system as you have done before using losetup and mount 1 - Solution sudo losetup -P /dev/loop50 imgs/2024-11-19-raspios-bookworm-arm64-lite.img sudo mount /dev/loop50p2 /mnt/rpi Now the image is mounted, we can modify it (writing files, configuring parameters, etc). 2 - Issue Change the name raspberrypi name with the name of your choice : In the /etc/hosts file of the Raspberry Pi OS image, which is used to translate the host name into its ip address. In the /etc/hostname file of the Raspberry Pi OS image, which is used to define the hostname Warning Be careful not to modify your local OS' files, but those in /mnt/rpi 2 - Solution Change the name raspberry with the name you have chosen before : sudo nano /mnt/rpi/etc/hosts sudo nano /mnt/rpi/etc/hostname Clean end sudo umount /mnt/rpi sudo losetup -d /dev/loop50","title":"D. Modifying the Raspberry Pi OS image"},{"location":"image/lab1/modifying/#d-modifying-the-raspberry-pi-os-image","text":"1 - Issue First mount the image's root file system as you have done before using losetup and mount 1 - Solution sudo losetup -P /dev/loop50 imgs/2024-11-19-raspios-bookworm-arm64-lite.img sudo mount /dev/loop50p2 /mnt/rpi Now the image is mounted, we can modify it (writing files, configuring parameters, etc). 2 - Issue Change the name raspberrypi name with the name of your choice : In the /etc/hosts file of the Raspberry Pi OS image, which is used to translate the host name into its ip address. In the /etc/hostname file of the Raspberry Pi OS image, which is used to define the hostname Warning Be careful not to modify your local OS' files, but those in /mnt/rpi 2 - Solution Change the name raspberry with the name you have chosen before : sudo nano /mnt/rpi/etc/hosts sudo nano /mnt/rpi/etc/hostname Clean end sudo umount /mnt/rpi sudo losetup -d /dev/loop50","title":"D. Modifying the Raspberry Pi OS image"},{"location":"image/lab1/mounting/","text":"B. Mounting the Raspberry Pi OS image on the host The Raspberry Pi OS image has 2 partitions : rootfs and boot. We will now mount these partitions on the host to get access to the files and folders in the image. The boot partition contains bootloader information (used at start). The rootfs partition contains the file system of raspios bookworm. Definition Mounting a partition is the act of making the filesystem on that partition accessible at a specific location in the directory tree so the operating system can read from and write to it. We will now mount the rootfs partition on our computer to have access to the file system of raspios bookworm. Note We will go throuhg 2 different methods. The first one will teach us more how the image is structured. The second one is more efficient and recommended. First method (Intuitive) 1 - Issue Use the fdisk command with the correct option to display a list of partitions in your img file You may use sudo to get permission Tip Use fdisk -h to learn more about the existing options 1 - Solution sudo fdisk -l imgs/2024-11-19-raspios-bookworm-arm64-lite.img You must get something like: Disk imgs/2024-11-19-raspios-bookworm-arm64-lite.img: 2 .57 GiB, 2755657728 bytes, 5382144 sectors Units: sectors of 1 * 512 = 512 bytes Sector size ( logical/physical ) : 512 bytes / 512 bytes I/O size ( minimum/optimal ) : 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x8a438930 Device Boot Start End Sectors Size Id Type imgs/2024-11-19-raspios-bookworm-arm64-lite.img1 8192 1056767 1048576 512M c W95 FAT32 ( LBA ) imgs/2024-11-19-raspios-bookworm-arm64-lite.img2 1056768 5382143 4325376 2 .1G 83 Linux Get the starting point of the partitions contained in the image Here, partition 1 (boot) starts at block 8192 and partition2 (rootfs) starts at block 1056768. The block size is 512 bytes. Check yours Note Why does the first partition start at sector 8192 ? In order to leave space at the beginning for : Bootloader data Alignment (important for SD cards) This is common in Raspberry Pi images We first create an access file to mount the main partition (partition 2) on our computer sudo mkdir -p /mnt/rpi Note The /mnt mount directory is where external partitions are located when mounted on Linux Ubuntu. For example when you plug an external storage device (SSD, USB key, etc) Then we will use the mount command to mount the partitions. This is the standard way to mount a partition, i.e. to give access to the folders and files on the partition. Note mount automatically detect the partition type (linux ext4, dos, ntfs, ...). We mount partition 2 with the root file system sudo mount -o loop,offset = $(( 1056768 * 512 )) imgs/2024-11-19-raspios-bookworm-arm64-lite.img /mnt/rpi We check that the file system of Raspberry PI OS is there : ls /mnt/rpi Then we unmount the partition sudo umount /mnt/rpi We create an access file to mount the other partition (partition 1) sudo mkdir -p /mnt/rpi/boot sudo mount -o loop,offset = $(( 8192 * 512 )) imgs/2024-11-19-raspios-bookworm-arm64-lite.img /mnt/rpi/boot We can display the content of the boot folder : ls /mnt/rpi/boot and we unmount the partition to cleanly exit sudo umount /mnt/rpi/boot sudo rmdir /mnt/rpi/boot Warning The main problem of this method is that we cannot mount simultaneously the two partitions at the right places /mnt/rpi and /mnt/rpi/boot because an overlapping error occurs. Second method (Recommended) loop devices are virtual block devices that map a file to a disk-like interface. They let Linux treat a regular file as if it were a real disk or partition. We search for a non used loop device (/dev/loop??), list existing loop devices : lsblk For example /dev/loop50 is not used on my computer, I will use it here. 2 - Issue The losetup command allows controlling loop devices. Learn how to use the -P option in order to create a partitioned loop device, say /dev/loop50 from your Raspberry Pi OS image. Tip Use losetup -P <loop_device> <img> 2 - Solution sudo losetup -P /dev/loop50 imgs/2024-11-19-raspios-bookworm-arm64-lite.img The -P option find the 2 partitions and give them these names : partition 1 : /dev/loop50p1 (name: boot) partition 2 : /dev/loop50p2 (name: rootfs) Check your loop devices with lsblk 3 - Issue Create a folder to access the mount (already done before in method 1 !) Then, mount partition 2 with the root file system using mount (no need for the -o option) Finally, mount the boot partition at the right place in the root file system : look for a boot directory Tip You should use sudo mount <source> <directory> 3 - Solution Create the folder to access the mount sudo mkdir -p /mnt/rpi Then mount the file system partition (rootfs) sudo mount /dev/loop50p2 /mnt/rpi ls /mnt/rpi and mount the boot partition sudo mount /dev/loop50p1 /mnt/rpi/boot ls /mnt/rpi/boot Finally, we unmount the partitions to cleanly exit sudo umount /mnt/rpi/boot sudo umount /mnt/rpi sudo losetup -d /dev/loop50 Warning To cleanly exit : make the last 3 commands, in the right order, do not execute the next command if the previous has failed.","title":"B. Mounting the Raspberry Pi OS image on the host"},{"location":"image/lab1/mounting/#b-mounting-the-raspberry-pi-os-image-on-the-host","text":"The Raspberry Pi OS image has 2 partitions : rootfs and boot. We will now mount these partitions on the host to get access to the files and folders in the image. The boot partition contains bootloader information (used at start). The rootfs partition contains the file system of raspios bookworm. Definition Mounting a partition is the act of making the filesystem on that partition accessible at a specific location in the directory tree so the operating system can read from and write to it. We will now mount the rootfs partition on our computer to have access to the file system of raspios bookworm. Note We will go throuhg 2 different methods. The first one will teach us more how the image is structured. The second one is more efficient and recommended.","title":"B. Mounting the Raspberry Pi OS image on the host"},{"location":"image/lab1/mounting/#first-method-intuitive","text":"1 - Issue Use the fdisk command with the correct option to display a list of partitions in your img file You may use sudo to get permission Tip Use fdisk -h to learn more about the existing options 1 - Solution sudo fdisk -l imgs/2024-11-19-raspios-bookworm-arm64-lite.img You must get something like: Disk imgs/2024-11-19-raspios-bookworm-arm64-lite.img: 2 .57 GiB, 2755657728 bytes, 5382144 sectors Units: sectors of 1 * 512 = 512 bytes Sector size ( logical/physical ) : 512 bytes / 512 bytes I/O size ( minimum/optimal ) : 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x8a438930 Device Boot Start End Sectors Size Id Type imgs/2024-11-19-raspios-bookworm-arm64-lite.img1 8192 1056767 1048576 512M c W95 FAT32 ( LBA ) imgs/2024-11-19-raspios-bookworm-arm64-lite.img2 1056768 5382143 4325376 2 .1G 83 Linux Get the starting point of the partitions contained in the image Here, partition 1 (boot) starts at block 8192 and partition2 (rootfs) starts at block 1056768. The block size is 512 bytes. Check yours Note Why does the first partition start at sector 8192 ? In order to leave space at the beginning for : Bootloader data Alignment (important for SD cards) This is common in Raspberry Pi images We first create an access file to mount the main partition (partition 2) on our computer sudo mkdir -p /mnt/rpi Note The /mnt mount directory is where external partitions are located when mounted on Linux Ubuntu. For example when you plug an external storage device (SSD, USB key, etc) Then we will use the mount command to mount the partitions. This is the standard way to mount a partition, i.e. to give access to the folders and files on the partition. Note mount automatically detect the partition type (linux ext4, dos, ntfs, ...). We mount partition 2 with the root file system sudo mount -o loop,offset = $(( 1056768 * 512 )) imgs/2024-11-19-raspios-bookworm-arm64-lite.img /mnt/rpi We check that the file system of Raspberry PI OS is there : ls /mnt/rpi Then we unmount the partition sudo umount /mnt/rpi We create an access file to mount the other partition (partition 1) sudo mkdir -p /mnt/rpi/boot sudo mount -o loop,offset = $(( 8192 * 512 )) imgs/2024-11-19-raspios-bookworm-arm64-lite.img /mnt/rpi/boot We can display the content of the boot folder : ls /mnt/rpi/boot and we unmount the partition to cleanly exit sudo umount /mnt/rpi/boot sudo rmdir /mnt/rpi/boot Warning The main problem of this method is that we cannot mount simultaneously the two partitions at the right places /mnt/rpi and /mnt/rpi/boot because an overlapping error occurs.","title":"First method (Intuitive)"},{"location":"image/lab1/mounting/#second-method-recommended","text":"loop devices are virtual block devices that map a file to a disk-like interface. They let Linux treat a regular file as if it were a real disk or partition. We search for a non used loop device (/dev/loop??), list existing loop devices : lsblk For example /dev/loop50 is not used on my computer, I will use it here. 2 - Issue The losetup command allows controlling loop devices. Learn how to use the -P option in order to create a partitioned loop device, say /dev/loop50 from your Raspberry Pi OS image. Tip Use losetup -P <loop_device> <img> 2 - Solution sudo losetup -P /dev/loop50 imgs/2024-11-19-raspios-bookworm-arm64-lite.img The -P option find the 2 partitions and give them these names : partition 1 : /dev/loop50p1 (name: boot) partition 2 : /dev/loop50p2 (name: rootfs) Check your loop devices with lsblk 3 - Issue Create a folder to access the mount (already done before in method 1 !) Then, mount partition 2 with the root file system using mount (no need for the -o option) Finally, mount the boot partition at the right place in the root file system : look for a boot directory Tip You should use sudo mount <source> <directory> 3 - Solution Create the folder to access the mount sudo mkdir -p /mnt/rpi Then mount the file system partition (rootfs) sudo mount /dev/loop50p2 /mnt/rpi ls /mnt/rpi and mount the boot partition sudo mount /dev/loop50p1 /mnt/rpi/boot ls /mnt/rpi/boot Finally, we unmount the partitions to cleanly exit sudo umount /mnt/rpi/boot sudo umount /mnt/rpi sudo losetup -d /dev/loop50 Warning To cleanly exit : make the last 3 commands, in the right order, do not execute the next command if the previous has failed.","title":"Second method (Recommended)"},{"location":"image/lab2/getting/","text":"A. Getting the Raspberry Pi OS image Warning Unfortunately, there is still no working QEMU emulation specific kernel for Bookworm at the time of this Lab So, in order to learn how to emulate a Raspberry Pi with QEMU VM, we will download a Buster image. However, make sure to keep your Bookworm image from Lab 1 as we will use it in Lab 3 1 - Issue Follow the instructions in Getting the Raspberry Pi OS image from the previous lab to download and decompress the Raspberry PI OS Lite Buster version from 2021/05/07 (or 2021/05/08). 1 - Solution cd rpilab/imgs wget https://downloads.raspberrypi.org/raspios_lite_armhf/images/raspios_lite_armhf-2021-05-28/2021-05-07-raspios-buster-armhf-lite.zip unzip 2021 -05-07-raspios-buster-armhf-lite.zip cd ..","title":"A. Getting the Raspberry Pi OS image"},{"location":"image/lab2/getting/#a-getting-the-raspberry-pi-os-image","text":"Warning Unfortunately, there is still no working QEMU emulation specific kernel for Bookworm at the time of this Lab So, in order to learn how to emulate a Raspberry Pi with QEMU VM, we will download a Buster image. However, make sure to keep your Bookworm image from Lab 1 as we will use it in Lab 3 1 - Issue Follow the instructions in Getting the Raspberry Pi OS image from the previous lab to download and decompress the Raspberry PI OS Lite Buster version from 2021/05/07 (or 2021/05/08). 1 - Solution cd rpilab/imgs wget https://downloads.raspberrypi.org/raspios_lite_armhf/images/raspios_lite_armhf-2021-05-28/2021-05-07-raspios-buster-armhf-lite.zip unzip 2021 -05-07-raspios-buster-armhf-lite.zip cd ..","title":"A. Getting the Raspberry Pi OS image"},{"location":"image/lab2/installVM/","text":"B. Install QEMU ARM virtual machine (VM) Install require packages for QEMU virtual machine (QEMU VM). Update package manager sudo apt update Install packages for the QEMU VM sudo apt install qemu-system-arm qemu-kvm \\ libvirt-clients libvirt-daemon-system bridge-utils \\ virtinst libvirt-daemon virt-manager Note If you get problems with lmv2 during install, run: sudo apt purge lvm2 sudo apt install lvm2 When running Raspberry PI OS in the QEMU VM, we need the Linux kernel and drivers to be compatible with an execution on a QEMU VM instead of the actual RPI board. They are available here : https://github.com/dhruvvyas90/qemu-rpi-kernel We assume that we are in the rpilab folder clone the git repo with kernels and drivers git clone https://github.com/dhruvvyas90/qemu-rpi-kernel to avoid problems of git submodules, you can remove the .git folder rm -Rf qemu-rpi-kernel/.git","title":"B. Install QEMU ARM virtual machine (VM)"},{"location":"image/lab2/installVM/#b-install-qemu-arm-virtual-machine-vm","text":"Install require packages for QEMU virtual machine (QEMU VM). Update package manager sudo apt update Install packages for the QEMU VM sudo apt install qemu-system-arm qemu-kvm \\ libvirt-clients libvirt-daemon-system bridge-utils \\ virtinst libvirt-daemon virt-manager Note If you get problems with lmv2 during install, run: sudo apt purge lvm2 sudo apt install lvm2 When running Raspberry PI OS in the QEMU VM, we need the Linux kernel and drivers to be compatible with an execution on a QEMU VM instead of the actual RPI board. They are available here : https://github.com/dhruvvyas90/qemu-rpi-kernel We assume that we are in the rpilab folder clone the git repo with kernels and drivers git clone https://github.com/dhruvvyas90/qemu-rpi-kernel to avoid problems of git submodules, you can remove the .git folder rm -Rf qemu-rpi-kernel/.git","title":"B. Install QEMU ARM virtual machine (VM)"},{"location":"image/lab2/intro/","text":"Lab 2 - Introduction Objectives Running the Raspberry Pi OS on a virtual machine on host Getting the Raspberry Pi OS (formerly Raspbian) image Installing Virtual Machine (QEMU VM) software on the host Preparing the image to run it in the QEMU VM Executing QEMU VM Installing ROS2 from source code or using docker Note The host or the host computer is the physical machine on which you will execute the Raspberry Pi OS. In this lab it is your laptop.","title":"Lab 2 - Introduction"},{"location":"image/lab2/intro/#lab-2-introduction","text":"","title":"Lab 2 - Introduction"},{"location":"image/lab2/intro/#objectives","text":"Running the Raspberry Pi OS on a virtual machine on host Getting the Raspberry Pi OS (formerly Raspbian) image Installing Virtual Machine (QEMU VM) software on the host Preparing the image to run it in the QEMU VM Executing QEMU VM Installing ROS2 from source code or using docker Note The host or the host computer is the physical machine on which you will execute the Raspberry Pi OS. In this lab it is your laptop.","title":"Objectives"},{"location":"image/lab2/using/","text":"C. Using QEMU Virtual Machine Starting QEMU VM Raspberry Pi OS images do not boot directly in QEMU without: A custom kernel Correct DTB (a binary hardware description file that tells the Linux kernel which hardware it is running on) Proper machine type In qemu-rpi-kernel you will find kernels built specifically for QEMU emulation. As you can see, these don't go until the Bookworm version, this is why we use a Buster image The first time, we start with a shell (console /bin/bash) to configure the execution of the VM. qemu-system-arm \\ -kernel qemu-rpi-kernel/kernel-qemu-4.19.50-buster \\ -cpu arm1176 \\ -m 256 \\ -M versatilepb \\ -no-reboot \\ -serial stdio \\ -append \"root=/dev/sda2 panic=1 rootfstype=ext4 rw init=/bin/bash\" \\ -drive \"file=imgs/2021-05-07-raspios-buster-armhf-lite.img,index=0,media=disk,format=raw\" \\ -dtb qemu-rpi-kernel/versatile-pb-buster.dtb Tip Look for the default login and password on a Rapsberry Pi We add a special rule to have the disk devices named /dev/sd? instead of /dev/mmcblk? (simpler naming for the disk drives) Create the file rule file /etc/udev/rules.d/90-qemu.rules cat << EOF > /etc/udev/rules.d/90-qemu.rules KERNEL==\"sda\", SYMLINK+=\"mmcblk0\" KERNEL==\"sda?\", \\ SYMLINK+=\"mmcblk0p%n\" KERNEL==\"sda2\", SYMLINK+=\"root\" EOF Terminate the execution of VM by typing ctrl-D Executing QEMU VM We would like to be able to access the QEMU VM with ssh Problem : the VM has localhost IP address, same as host. To solve it, we use port mapping : tcp port 10022 of the host will be mapped to port 22 on the QEMU VM Then ssh will work using port 10022 and localhost qemu-system-arm \\ -kernel qemu-rpi-kernel/kernel-qemu-4.19.50-buster \\ -cpu arm1176 \\ -m 256 \\ -M versatilepb \\ -no-reboot \\ -serial stdio \\ -append \"root=/dev/sda2 panic=1 rootfstype=ext4 rw\" \\ -drive \"file=imgs/2021-05-07-raspios-buster-armhf-lite.img,index=0,media=disk,format=raw\" \\ -dtb qemu-rpi-kernel/versatile-pb-buster.dtb \\ -net nic -net user,hostfwd = tcp::10022-:22 The QEMU VM is ready to be used with 3 possible access : QEMU window, console and ssh. Tip To be untrapped in QEMU window, type ctrl-alt-g But there is still one step missing for ssh to work. Setting up network for ssh access The RPI image (even the lite one) has all softwares installed to access it via ssh. However, port 22 is not accessible by default ! We can enable ssh by adding an empty file simply called ssh in the boot folder 1 -Issue Use the QEMU VM console with user pi to create the /boot/ssh file with touch 1 - Solution Start QEMU with a shell : qemu-system-arm \\ -kernel qemu-rpi-kernel/kernel-qemu-4.19.50-buster \\ -cpu arm1176 \\ -m 256 \\ -M versatilepb \\ -no-reboot \\ -serial stdio \\ -append \"root=/dev/sda2 panic=1 rootfstype=ext4 rw init=/bin/bash\" \\ -drive \"file=imgs/2021-05-07-raspios-buster-armhf-lite.img,index=0,media=disk,format=raw\" \\ -dtb qemu-rpi-kernel/versatile-pb-buster.dtb and use sudo touch /boot/ssh then leave QEMU Note You can also use chroot with your bash scripts start_chroot.sh and stop_chroot.sh After restarting the qemu vm, the ssh command should work fine. 2 -Issue On an other terminal, connect to the QEMU VM from the host via ssh Look for the relevant ssh option to use the right port which is not the default 22. Tip The ip address is your localhost ipaddress so you can use the shortcut pi@localhost 2 - Solution ssh -p 10022 pi@localhost You can stop QEMU and delete the Buster image after this lab.","title":"C. Using QEMU Virtual Machine"},{"location":"image/lab2/using/#c-using-qemu-virtual-machine","text":"","title":"C. Using QEMU Virtual Machine"},{"location":"image/lab2/using/#starting-qemu-vm","text":"Raspberry Pi OS images do not boot directly in QEMU without: A custom kernel Correct DTB (a binary hardware description file that tells the Linux kernel which hardware it is running on) Proper machine type In qemu-rpi-kernel you will find kernels built specifically for QEMU emulation. As you can see, these don't go until the Bookworm version, this is why we use a Buster image The first time, we start with a shell (console /bin/bash) to configure the execution of the VM. qemu-system-arm \\ -kernel qemu-rpi-kernel/kernel-qemu-4.19.50-buster \\ -cpu arm1176 \\ -m 256 \\ -M versatilepb \\ -no-reboot \\ -serial stdio \\ -append \"root=/dev/sda2 panic=1 rootfstype=ext4 rw init=/bin/bash\" \\ -drive \"file=imgs/2021-05-07-raspios-buster-armhf-lite.img,index=0,media=disk,format=raw\" \\ -dtb qemu-rpi-kernel/versatile-pb-buster.dtb Tip Look for the default login and password on a Rapsberry Pi We add a special rule to have the disk devices named /dev/sd? instead of /dev/mmcblk? (simpler naming for the disk drives) Create the file rule file /etc/udev/rules.d/90-qemu.rules cat << EOF > /etc/udev/rules.d/90-qemu.rules KERNEL==\"sda\", SYMLINK+=\"mmcblk0\" KERNEL==\"sda?\", \\ SYMLINK+=\"mmcblk0p%n\" KERNEL==\"sda2\", SYMLINK+=\"root\" EOF Terminate the execution of VM by typing ctrl-D","title":"Starting QEMU VM"},{"location":"image/lab2/using/#executing-qemu-vm","text":"We would like to be able to access the QEMU VM with ssh Problem : the VM has localhost IP address, same as host. To solve it, we use port mapping : tcp port 10022 of the host will be mapped to port 22 on the QEMU VM Then ssh will work using port 10022 and localhost qemu-system-arm \\ -kernel qemu-rpi-kernel/kernel-qemu-4.19.50-buster \\ -cpu arm1176 \\ -m 256 \\ -M versatilepb \\ -no-reboot \\ -serial stdio \\ -append \"root=/dev/sda2 panic=1 rootfstype=ext4 rw\" \\ -drive \"file=imgs/2021-05-07-raspios-buster-armhf-lite.img,index=0,media=disk,format=raw\" \\ -dtb qemu-rpi-kernel/versatile-pb-buster.dtb \\ -net nic -net user,hostfwd = tcp::10022-:22 The QEMU VM is ready to be used with 3 possible access : QEMU window, console and ssh. Tip To be untrapped in QEMU window, type ctrl-alt-g But there is still one step missing for ssh to work.","title":"Executing QEMU VM"},{"location":"image/lab2/using/#setting-up-network-for-ssh-access","text":"The RPI image (even the lite one) has all softwares installed to access it via ssh. However, port 22 is not accessible by default ! We can enable ssh by adding an empty file simply called ssh in the boot folder 1 -Issue Use the QEMU VM console with user pi to create the /boot/ssh file with touch 1 - Solution Start QEMU with a shell : qemu-system-arm \\ -kernel qemu-rpi-kernel/kernel-qemu-4.19.50-buster \\ -cpu arm1176 \\ -m 256 \\ -M versatilepb \\ -no-reboot \\ -serial stdio \\ -append \"root=/dev/sda2 panic=1 rootfstype=ext4 rw init=/bin/bash\" \\ -drive \"file=imgs/2021-05-07-raspios-buster-armhf-lite.img,index=0,media=disk,format=raw\" \\ -dtb qemu-rpi-kernel/versatile-pb-buster.dtb and use sudo touch /boot/ssh then leave QEMU Note You can also use chroot with your bash scripts start_chroot.sh and stop_chroot.sh After restarting the qemu vm, the ssh command should work fine. 2 -Issue On an other terminal, connect to the QEMU VM from the host via ssh Look for the relevant ssh option to use the right port which is not the default 22. Tip The ip address is your localhost ipaddress so you can use the shortcut pi@localhost 2 - Solution ssh -p 10022 pi@localhost You can stop QEMU and delete the Buster image after this lab.","title":"Setting up network for ssh access"},{"location":"image/lab3/connecting/","text":"B. Accessing the headless RPI without network Connecting the debug console Warning Make sure the Raspberry Pi is off (not powered) before proceeding the following steps ! First, insert the sd-card in the Raspberry Pi The console will be connected on the I/O ports on the RPI board and on an USB input of the host computer. The serial to USB adapter is a FTDI USB cable with 3, 4 or 6 \u201dArduino like\u201d terminations to be plugged on the RPI board, you can find some information in the data sheet of the cable : The one with 3 terminations : https://www.mouser.fr/datasheet/2/163/DS_TTL-232R_RPi-267577.pdf The one with 6 terminations : https://cdn.robotshop.com/media/s/spa/rb-spa-432/pdf/ftdi-cable-schematic-dev-09718.pdf The one with 4 terminations : https://www.adafruit.com/product/954?srsltid=AfmBOoploJ4nyapeY4tQLdr9ZWopzSrvJaUvqjKPwxA8N61XxzHrdqi4 Warning Caution! The GPIO pins on the Raspberry Pi are NOT 5V tolerant. That means you must use a 3.3V USB-to-serial converter. Look at the GPIO pinout for the Raspberry Pi 3, and find the UART pins. Plug the 3 necessary terminations of the FTDI USB cable on the board accordingly. Now this is done, power up the board ! Set-up the FTDI USB cable connection on a serial port of the host First, let's get the name of the serial port on the host. The /dev/ directory consists of files that represent devices that are attached to the local system. Before plugin the FTDI USB cable, check the system messages : sudo dmesg and list the devices : ls /dev | grep \"tty\" Now, plug the FTDI cable and check again. dmesg should tell you about a new connection and the devices list should display a new device 1 - Issue Find the name of the serial port. It should be something like /dev/tty* Note If you are using Windows, you will need to know the COM port number connected to your USB to serial adapter, which can be found in the Device Manager 1 - Solution The name of serial port should be something like /dev/ttyUSB0 Check it works with : stty -F <serial_port_name> If the command works only with sudo, you need to be added to the dialout group, which gives full and direct access to serial ports. First, check the groups you are member of : groups If dialout is not in the list , do sudo usermod -a -G dialout $USER and restart the computer ... or not !!! if you don\u2019t want to restart the session, remember this trick (the scope of this command is only the current shell): su - $USER Warning Be careful, the su - $USER command only add you in the dialout group for the terminal where you used it. But, when you will restart your computer, all your terminals will open with your user already in dialout group, and you will not need to use su - $USER again. now dialout should be in the group list groups Access the RPI from the host Once the RPI boot has booted, we can access it from the host with tools like minicom . the speed should be 115200 bauds 2 - Issue Start minicom specifying the device name and a baudrate of 115200 using the correct options 2 - Solution minicom -b 115200 -D /dev/ttyUSB0 Note On windows use Putty is a straight-forward solution to connect to serial ports If you still pefer using minicom under WSL, you need to use usbipd but it needs more setup The first time using minicom, the \"Hardware control flow\" must be disabled : type ctrl-A then o to access the configuration select \"Serial port setup\" type F to disable Hardware Flow Control select \"Save setup as dfl\" so that next time you will not need to reconfigure finally select \"Exit\" The login prompt should appear one or two minutes after powering the RPI board. Type user and passwd to log in. You can use ue41 user you have created in Lab 1. Check your hostname is the one you set in Lab 1 : hostname","title":"B. Accessing the headless RPI without network"},{"location":"image/lab3/connecting/#b-accessing-the-headless-rpi-without-network","text":"","title":"B. Accessing the headless RPI without network"},{"location":"image/lab3/connecting/#connecting-the-debug-console","text":"Warning Make sure the Raspberry Pi is off (not powered) before proceeding the following steps ! First, insert the sd-card in the Raspberry Pi The console will be connected on the I/O ports on the RPI board and on an USB input of the host computer. The serial to USB adapter is a FTDI USB cable with 3, 4 or 6 \u201dArduino like\u201d terminations to be plugged on the RPI board, you can find some information in the data sheet of the cable : The one with 3 terminations : https://www.mouser.fr/datasheet/2/163/DS_TTL-232R_RPi-267577.pdf The one with 6 terminations : https://cdn.robotshop.com/media/s/spa/rb-spa-432/pdf/ftdi-cable-schematic-dev-09718.pdf The one with 4 terminations : https://www.adafruit.com/product/954?srsltid=AfmBOoploJ4nyapeY4tQLdr9ZWopzSrvJaUvqjKPwxA8N61XxzHrdqi4 Warning Caution! The GPIO pins on the Raspberry Pi are NOT 5V tolerant. That means you must use a 3.3V USB-to-serial converter. Look at the GPIO pinout for the Raspberry Pi 3, and find the UART pins. Plug the 3 necessary terminations of the FTDI USB cable on the board accordingly. Now this is done, power up the board !","title":"Connecting the debug console"},{"location":"image/lab3/connecting/#set-up-the-ftdi-usb-cable-connection-on-a-serial-port-of-the-host","text":"First, let's get the name of the serial port on the host. The /dev/ directory consists of files that represent devices that are attached to the local system. Before plugin the FTDI USB cable, check the system messages : sudo dmesg and list the devices : ls /dev | grep \"tty\" Now, plug the FTDI cable and check again. dmesg should tell you about a new connection and the devices list should display a new device 1 - Issue Find the name of the serial port. It should be something like /dev/tty* Note If you are using Windows, you will need to know the COM port number connected to your USB to serial adapter, which can be found in the Device Manager 1 - Solution The name of serial port should be something like /dev/ttyUSB0 Check it works with : stty -F <serial_port_name> If the command works only with sudo, you need to be added to the dialout group, which gives full and direct access to serial ports. First, check the groups you are member of : groups If dialout is not in the list , do sudo usermod -a -G dialout $USER and restart the computer ... or not !!! if you don\u2019t want to restart the session, remember this trick (the scope of this command is only the current shell): su - $USER Warning Be careful, the su - $USER command only add you in the dialout group for the terminal where you used it. But, when you will restart your computer, all your terminals will open with your user already in dialout group, and you will not need to use su - $USER again. now dialout should be in the group list groups","title":"Set-up the FTDI USB cable connection on a serial port of the host"},{"location":"image/lab3/connecting/#access-the-rpi-from-the-host","text":"Once the RPI boot has booted, we can access it from the host with tools like minicom . the speed should be 115200 bauds 2 - Issue Start minicom specifying the device name and a baudrate of 115200 using the correct options 2 - Solution minicom -b 115200 -D /dev/ttyUSB0 Note On windows use Putty is a straight-forward solution to connect to serial ports If you still pefer using minicom under WSL, you need to use usbipd but it needs more setup The first time using minicom, the \"Hardware control flow\" must be disabled : type ctrl-A then o to access the configuration select \"Serial port setup\" type F to disable Hardware Flow Control select \"Save setup as dfl\" so that next time you will not need to reconfigure finally select \"Exit\" The login prompt should appear one or two minutes after powering the RPI board. Type user and passwd to log in. You can use ue41 user you have created in Lab 1. Check your hostname is the one you set in Lab 1 : hostname","title":"Access the RPI from the host"},{"location":"image/lab3/debug/","text":"Debug This section tries to solve some of the problems encountered with the students during the lab Nothing appears in minicom Make sure you are in the dialout group in the terminal from which you launch minicom, because even if you've already done the adding, it may not be effective ! Before starting minicom, check using the following command : groups If dialout doesn't appear, refer to the Set-up the FTDI USB cable connection on a serial port of the host section in B. Accessing the headless RPI without network section to solve this. Make sure the wiring is correct. In UART, Rx goes on Tx and Tx on Rx. Make sure the FTDI USB cable is 3.3V and not 5V as it can permanently damage the board The sd-card must be plugged in the RPI in the sd port, not with a usb adapter Make sure there is the line enable_uart=1 at the end of the /boot/config.txt of your Raspberry Pi OS image. If not, refer to the Enable serial interface and login shell over serial section in A. Writing the Raspberry Pi OS image on the sd-card section to solve this. Make sure you are using the Raspberry Pi OS Bookworm image from Lab 1 on the sd card If nothing of these solves the issue, the cause is probably hardware either from your computer (ex: failing usb port) or from the RPI setup (ex: failing FTDI USB, failing sd-card, ...) You can't access or write on the sd-card when it is plugged on your computer Try formatting the card, if you can't don't insist, the sd card is probably dead. You can't use nmcli Make sure you are using the Raspberry Pi OS Bookworm (or newer) image from Lab 1 on the sd card Older versions of Raspberry Pi OS don't use nmcli but /etc/wpa_supplicant.conf and /etc/dhcpch.conf files.","title":"Debug"},{"location":"image/lab3/debug/#debug","text":"This section tries to solve some of the problems encountered with the students during the lab","title":"Debug"},{"location":"image/lab3/debug/#nothing-appears-in-minicom","text":"Make sure you are in the dialout group in the terminal from which you launch minicom, because even if you've already done the adding, it may not be effective ! Before starting minicom, check using the following command : groups If dialout doesn't appear, refer to the Set-up the FTDI USB cable connection on a serial port of the host section in B. Accessing the headless RPI without network section to solve this. Make sure the wiring is correct. In UART, Rx goes on Tx and Tx on Rx. Make sure the FTDI USB cable is 3.3V and not 5V as it can permanently damage the board The sd-card must be plugged in the RPI in the sd port, not with a usb adapter Make sure there is the line enable_uart=1 at the end of the /boot/config.txt of your Raspberry Pi OS image. If not, refer to the Enable serial interface and login shell over serial section in A. Writing the Raspberry Pi OS image on the sd-card section to solve this. Make sure you are using the Raspberry Pi OS Bookworm image from Lab 1 on the sd card If nothing of these solves the issue, the cause is probably hardware either from your computer (ex: failing usb port) or from the RPI setup (ex: failing FTDI USB, failing sd-card, ...)","title":"Nothing appears in minicom"},{"location":"image/lab3/debug/#you-cant-access-or-write-on-the-sd-card-when-it-is-plugged-on-your-computer","text":"Try formatting the card, if you can't don't insist, the sd card is probably dead.","title":"You can't access or write on the sd-card when it is plugged on your computer"},{"location":"image/lab3/debug/#you-cant-use-nmcli","text":"Make sure you are using the Raspberry Pi OS Bookworm (or newer) image from Lab 1 on the sd card Older versions of Raspberry Pi OS don't use nmcli but /etc/wpa_supplicant.conf and /etc/dhcpch.conf files.","title":"You can't use nmcli"},{"location":"image/lab3/intro/","text":"Lab 3 - Introduction Objectives Setting-up and working with the Raspberry Pi OS without graphical user interface Using the Raspberry Pi OS image configured in the previous labs Creating the sd-card with the image No network ? Don\u2019t worry , connect a console ... Setting up the network (Wi-Fi and Ethernet) Setting up ssh Required materials Raspberry Pi 3 Model B Raspberry Pi power supply FTDI USB cable Sd-card Sd-card adapter References https://www.raspberrypi.com/documentation/computers https://learn.sparkfun.com/tutorials/headless-raspberry-pi-setup https://apical.xyz/fiches/l_unite_centrale_du_systeme_domotique_002/configurer_le_reseau_wi-fi_sur_le_raspberry_pi","title":"Lab 3 - Introduction"},{"location":"image/lab3/intro/#lab-3-introduction","text":"","title":"Lab 3 - Introduction"},{"location":"image/lab3/intro/#objectives","text":"Setting-up and working with the Raspberry Pi OS without graphical user interface Using the Raspberry Pi OS image configured in the previous labs Creating the sd-card with the image No network ? Don\u2019t worry , connect a console ... Setting up the network (Wi-Fi and Ethernet) Setting up ssh","title":"Objectives"},{"location":"image/lab3/intro/#required-materials","text":"Raspberry Pi 3 Model B Raspberry Pi power supply FTDI USB cable Sd-card Sd-card adapter","title":"Required materials"},{"location":"image/lab3/intro/#references","text":"https://www.raspberrypi.com/documentation/computers https://learn.sparkfun.com/tutorials/headless-raspberry-pi-setup https://apical.xyz/fiches/l_unite_centrale_du_systeme_domotique_002/configurer_le_reseau_wi-fi_sur_le_raspberry_pi","title":"References"},{"location":"image/lab3/saving/","text":"D. Cloning the image (not working ...) To save all the changes made on the Raspberry PI image, we can clone the image from the sd-card After stopping the RPI (unplug the power supply) , we remove the sd-card and mount it on the computer With dd The sd-card may be larger than the Raspberry OS image (for example 32 Gb sd-card for our image of 4 Gb). If the partition /dev/sd?2 is very large with lot of empty space, gparted command can be used to shrink it before doing dd : sudo gparted /dev/sd?2 Then resize the image to the minimum size + few space We use the fdisk command to get the actual size of the image. Replace ? in /dev/sd? with the right letter: sudo fdisk -l /dev/sd? The number of blocks is given is the \u201dEnd\u201d value for \u201d/dev/sd?2\u201d (ex 8724479). We use this count in the dd command to copy back the modifed Raspberry OS image on our computer. copy the image from the sd-card to the computer : replace ? with the appropriate drive letter Warning When using the dd command make sure you don't overwrite the wrong partitions or you will get big trouble sudo dd if = /dev/sdb of = imgs/2024-11-19-raspios-bookworm-arm64-lite-modified-2024.img count = 8724479 bs = 512 Congrats ! You ended this lab series ! You will soon use your knowledge to configure an embedded Linux for a robot.","title":"D. Cloning the image (not working ...)"},{"location":"image/lab3/saving/#d-cloning-the-image-not-working","text":"To save all the changes made on the Raspberry PI image, we can clone the image from the sd-card After stopping the RPI (unplug the power supply) , we remove the sd-card and mount it on the computer","title":"D. Cloning the image (not working ...)"},{"location":"image/lab3/saving/#with-dd","text":"The sd-card may be larger than the Raspberry OS image (for example 32 Gb sd-card for our image of 4 Gb). If the partition /dev/sd?2 is very large with lot of empty space, gparted command can be used to shrink it before doing dd : sudo gparted /dev/sd?2 Then resize the image to the minimum size + few space We use the fdisk command to get the actual size of the image. Replace ? in /dev/sd? with the right letter: sudo fdisk -l /dev/sd? The number of blocks is given is the \u201dEnd\u201d value for \u201d/dev/sd?2\u201d (ex 8724479). We use this count in the dd command to copy back the modifed Raspberry OS image on our computer. copy the image from the sd-card to the computer : replace ? with the appropriate drive letter Warning When using the dd command make sure you don't overwrite the wrong partitions or you will get big trouble sudo dd if = /dev/sdb of = imgs/2024-11-19-raspios-bookworm-arm64-lite-modified-2024.img count = 8724479 bs = 512 Congrats ! You ended this lab series ! You will soon use your knowledge to configure an embedded Linux for a robot.","title":"With dd"},{"location":"image/lab3/setting/","text":"C. Setting up network for ssh access Recap : 4 ways to access the RPI without network We have now 4 ways to setup the RPI image without network, for example to set the network parameters. Note that all these 4 ways do not require the use of a display connected on the HDMI plug and mouse+keyboard connected on the USB plugs of the RPI BOARD mount the RPI image (raspios bookworm) on host as a standard file system to modify configuration files chroot on the RPI sd-card image on host to directly execute RPI configuration commands on host QEMU virtual machine running the RPI image from the sd-card RPI console (terminal) on the actual RPI board via the FTDI USB cable, accessed with minicom (or similar tools) on the host If you do not want to use the serial terminal or want to be able to log in to your Raspberry Pi over a network connection, you can give your Pi a static IP address, connect it to your network (or to your computer via a crossover/Ethernet cable), and log in via SSH. We will now setup the network on the RPI The simplest way is using the 4th method: the RPI console(terminal) via the FTDI USB cable and minicom, because we can use the real board and raspi-config . Note Windows and Mac cannot natively access the filesystem partition of the Raspberry Pi image on the SD card because its format is ext4 , the native Linux filesystem format. As a result, the easiest solutions are to access a computer with a Linux operating system or to use the 4th method (which is our case now). Configure the network interfaces We are still connected to the RPI board via serial Enable Wifi To list all the network interfaces, we use the ifconfig command. There should be 3 interfaces : lo: local interface (no physical network) eth0: ethernet RJ45 wired network wlan0: Wi-Fi wireless (radio) network If wlan0 is not listed, as it is the case on a fresh install, you must specify the country where you use your device. This allows your device to choose the correct frequency bands for 5 GHz networking. We need to set the Wi-Fi country to FR. Use raspi-config to set WLAN country to France Configure a Wifi interface Since Raspberry Pi OS Bookworm (2023), the network is managed by NetworkManager, while on previous versions it was managed by dhcpcd. Note On versions older than Bookworm, there are 2 files to modify : /etc/wpa_supplicant/wpa_supplicant.conf : to set the Wi-Fi /etc/dhcpcd.conf : to set the IP addresses. Follow this tutorial if you need to do so : https://learn.sparkfun.com/tutorials/headless-raspberry-pi-setup A static IP address wil be use to simplify the access to the RPI via ssh. Both ethernet and Wi-Fi interfaces will be defined, each with a different IP address. Note For each network interface, a file will be created in /etc/NetworkManager/system-connections We configure the network with NetworkManager using the nmcli (Network Manager Command Line Interface) command tool. 1 - Issue Configure the Wifi connection to the iot (password: enstaL@b) network using nmcli Help on https://www.raspberrypi.com/documentation/computers/configuration.html#wireless-networking-command-line 1 - Solution sudo nmcli --ask dev wifi connect iot Enter password Now check a file has been created for your wifi interface in /etc/NetworkManager/system-connections ls /etc/NetworkManager/system-connections Have a look to the created file. It should look like this : [ connection ] id = iot uuid = 74a90378-23c2-493e-a524-138a17c10184 type = wifi interface-name = wlan0 [ wifi ] mode = infrastructure ssid = iot [ wifi-security ] auth-alg = open key-mgmt = wpa-psk psk = enstaL@b [ ipv4 ] method = auto [ ipv6 ] addr-gen-mode = default method = auto [ proxy ] Tip If we can't access the real board and we want to setup the network on the Raspberry Pi OS image from our computer, we would have to create and configure this file manually because nmcli doesn't work with chroot. It is possible to encrypt the password using the wpa_passphrase tool for security reasons but this is optional. wpa_passphrase <network_ssid> <password> This will return an encrypted password. Copy it in your wifi interface configuration file instead of the real password The iot network has internet connection, so you can try sudo apt update for example. Configure an ethernet interface We may want to use a ethernet cable to connect to the RPI (for example to get a higher data rate than via Wifi), in this case we can set eth0. First, find the ethernet connection name (probably something like Wired connection 1 or eth0 ): nmcli connection show sudo nmcli connection modify \"Wired connection 1\" \\ ipv4.method manual \\ ipv4.addresses 192 .168.1.10/24 \\ ipv4.gateway \"192.168.1.1\" \\ ipv4.dns \"172.0.0.35 172.0.0.37 8.8.8.8 8.8.4.4\" Apply the change : sudo nmcli connection down \"Wired connection 1\" sudo nmcli connection up \"Wired connection 1\" Trying to find the IP address of the RPI From the host via network In this case, suppose we don't have a FTDI USB cable and we configured the network interfaces on the RPI OS image on host We need to proceed to a systematic search over all the network of your hostname (the name you have given earlier in Lab 1). Note Can take a very long time with 16 bits masks. Faster, around one minute, with 24 bits masks. On host, we can scan all devices on the iot network, this takes quite a long time (1 minute or more). The iot network's ip address is 172.19.144.0 Be carefull, on iot the network mask is 255.255.252.0 or /22 2 - Issue Scan the iot network using nmap . Do this before and after booting up the raspberry pi, and find its ip address. Tip Find the correct option to do a Nmap Ping Scan , which is a lot quicker than using nmap without option. 2 - Solution nmap -sP 172 .19.144.0/22 With the console (via minicom) Note This second option is easier but we need a serial connection to the real board, so more hardware Simply show network configuration using ifconfig and look for inet. Enable ssh The RPI image (even the lite one) has all softwares installed to access it via ssh. However, port 22 is not accessible by default ! Try from host : ssh ue41@<ip_addr> The permission is denied ! Enable ssh on the RPI board using : sudo systemctl enable ssh Then start the service : sudo systemctl start ssh Check it is working : systemctl status ssh Note We can also do it with raspi-config Tip When preparing the OS image on host or on the sd-card we would simply create a ssh file in the boot folder. When booting the real board with this image, a first-boot service checks for /boot/ssh, and enable ssh if it finds it. It only works on first boot ! If you have already booted the board once with your image on your sd-card but you haven't created the /boot/ssh file before and you can't access the real board via serial, this method won't work. Instead : Either use chroot on the sd-card and type : sudo systemctl enable ssh Either create the /boot/ssh file on your local OS image and write it again on the sd-card Now try again : ssh ue41@<ip_addr> You should now be able to connect via ssh ! You finished the setup ! Congrats ! You ended this lab series ! You will soon use your knowledge to configure an embedded Linux for a robot.","title":"C. Setting up network for ssh access"},{"location":"image/lab3/setting/#c-setting-up-network-for-ssh-access","text":"","title":"C. Setting up network for ssh access"},{"location":"image/lab3/setting/#recap-4-ways-to-access-the-rpi-without-network","text":"We have now 4 ways to setup the RPI image without network, for example to set the network parameters. Note that all these 4 ways do not require the use of a display connected on the HDMI plug and mouse+keyboard connected on the USB plugs of the RPI BOARD mount the RPI image (raspios bookworm) on host as a standard file system to modify configuration files chroot on the RPI sd-card image on host to directly execute RPI configuration commands on host QEMU virtual machine running the RPI image from the sd-card RPI console (terminal) on the actual RPI board via the FTDI USB cable, accessed with minicom (or similar tools) on the host If you do not want to use the serial terminal or want to be able to log in to your Raspberry Pi over a network connection, you can give your Pi a static IP address, connect it to your network (or to your computer via a crossover/Ethernet cable), and log in via SSH. We will now setup the network on the RPI The simplest way is using the 4th method: the RPI console(terminal) via the FTDI USB cable and minicom, because we can use the real board and raspi-config . Note Windows and Mac cannot natively access the filesystem partition of the Raspberry Pi image on the SD card because its format is ext4 , the native Linux filesystem format. As a result, the easiest solutions are to access a computer with a Linux operating system or to use the 4th method (which is our case now).","title":"Recap : 4 ways to access the RPI without network"},{"location":"image/lab3/setting/#configure-the-network-interfaces","text":"We are still connected to the RPI board via serial","title":"Configure the network interfaces"},{"location":"image/lab3/setting/#enable-wifi","text":"To list all the network interfaces, we use the ifconfig command. There should be 3 interfaces : lo: local interface (no physical network) eth0: ethernet RJ45 wired network wlan0: Wi-Fi wireless (radio) network If wlan0 is not listed, as it is the case on a fresh install, you must specify the country where you use your device. This allows your device to choose the correct frequency bands for 5 GHz networking. We need to set the Wi-Fi country to FR. Use raspi-config to set WLAN country to France","title":"Enable Wifi"},{"location":"image/lab3/setting/#configure-a-wifi-interface","text":"Since Raspberry Pi OS Bookworm (2023), the network is managed by NetworkManager, while on previous versions it was managed by dhcpcd. Note On versions older than Bookworm, there are 2 files to modify : /etc/wpa_supplicant/wpa_supplicant.conf : to set the Wi-Fi /etc/dhcpcd.conf : to set the IP addresses. Follow this tutorial if you need to do so : https://learn.sparkfun.com/tutorials/headless-raspberry-pi-setup A static IP address wil be use to simplify the access to the RPI via ssh. Both ethernet and Wi-Fi interfaces will be defined, each with a different IP address. Note For each network interface, a file will be created in /etc/NetworkManager/system-connections We configure the network with NetworkManager using the nmcli (Network Manager Command Line Interface) command tool. 1 - Issue Configure the Wifi connection to the iot (password: enstaL@b) network using nmcli Help on https://www.raspberrypi.com/documentation/computers/configuration.html#wireless-networking-command-line 1 - Solution sudo nmcli --ask dev wifi connect iot Enter password Now check a file has been created for your wifi interface in /etc/NetworkManager/system-connections ls /etc/NetworkManager/system-connections Have a look to the created file. It should look like this : [ connection ] id = iot uuid = 74a90378-23c2-493e-a524-138a17c10184 type = wifi interface-name = wlan0 [ wifi ] mode = infrastructure ssid = iot [ wifi-security ] auth-alg = open key-mgmt = wpa-psk psk = enstaL@b [ ipv4 ] method = auto [ ipv6 ] addr-gen-mode = default method = auto [ proxy ] Tip If we can't access the real board and we want to setup the network on the Raspberry Pi OS image from our computer, we would have to create and configure this file manually because nmcli doesn't work with chroot. It is possible to encrypt the password using the wpa_passphrase tool for security reasons but this is optional. wpa_passphrase <network_ssid> <password> This will return an encrypted password. Copy it in your wifi interface configuration file instead of the real password The iot network has internet connection, so you can try sudo apt update for example.","title":"Configure a Wifi interface"},{"location":"image/lab3/setting/#configure-an-ethernet-interface","text":"We may want to use a ethernet cable to connect to the RPI (for example to get a higher data rate than via Wifi), in this case we can set eth0. First, find the ethernet connection name (probably something like Wired connection 1 or eth0 ): nmcli connection show sudo nmcli connection modify \"Wired connection 1\" \\ ipv4.method manual \\ ipv4.addresses 192 .168.1.10/24 \\ ipv4.gateway \"192.168.1.1\" \\ ipv4.dns \"172.0.0.35 172.0.0.37 8.8.8.8 8.8.4.4\" Apply the change : sudo nmcli connection down \"Wired connection 1\" sudo nmcli connection up \"Wired connection 1\"","title":"Configure an ethernet interface"},{"location":"image/lab3/setting/#trying-to-find-the-ip-address-of-the-rpi","text":"","title":"Trying to find the IP address of the RPI"},{"location":"image/lab3/setting/#from-the-host-via-network","text":"In this case, suppose we don't have a FTDI USB cable and we configured the network interfaces on the RPI OS image on host We need to proceed to a systematic search over all the network of your hostname (the name you have given earlier in Lab 1). Note Can take a very long time with 16 bits masks. Faster, around one minute, with 24 bits masks. On host, we can scan all devices on the iot network, this takes quite a long time (1 minute or more). The iot network's ip address is 172.19.144.0 Be carefull, on iot the network mask is 255.255.252.0 or /22 2 - Issue Scan the iot network using nmap . Do this before and after booting up the raspberry pi, and find its ip address. Tip Find the correct option to do a Nmap Ping Scan , which is a lot quicker than using nmap without option. 2 - Solution nmap -sP 172 .19.144.0/22","title":"From the host via network"},{"location":"image/lab3/setting/#with-the-console-via-minicom","text":"Note This second option is easier but we need a serial connection to the real board, so more hardware Simply show network configuration using ifconfig and look for inet.","title":"With the console (via minicom)"},{"location":"image/lab3/setting/#enable-ssh","text":"The RPI image (even the lite one) has all softwares installed to access it via ssh. However, port 22 is not accessible by default ! Try from host : ssh ue41@<ip_addr> The permission is denied ! Enable ssh on the RPI board using : sudo systemctl enable ssh Then start the service : sudo systemctl start ssh Check it is working : systemctl status ssh Note We can also do it with raspi-config Tip When preparing the OS image on host or on the sd-card we would simply create a ssh file in the boot folder. When booting the real board with this image, a first-boot service checks for /boot/ssh, and enable ssh if it finds it. It only works on first boot ! If you have already booted the board once with your image on your sd-card but you haven't created the /boot/ssh file before and you can't access the real board via serial, this method won't work. Instead : Either use chroot on the sd-card and type : sudo systemctl enable ssh Either create the /boot/ssh file on your local OS image and write it again on the sd-card Now try again : ssh ue41@<ip_addr> You should now be able to connect via ssh ! You finished the setup ! Congrats ! You ended this lab series ! You will soon use your knowledge to configure an embedded Linux for a robot.","title":"Enable ssh"},{"location":"image/lab3/writing/","text":"A. Writing the Raspberry Pi OS image on the sd-card In this part, we plan to write our Raspberry Pi OS image on a sd-card in order to use it on a real board. Warning Make sure to use the Raspberry Pi OS bookworm image you set up in Lab 1 Headless Raspberry Pi For convenience or to save space and money, we don't want to use additional hardware components such as a monitor, keyboard, or mouse to access our Raspberry Pi, especially with a desktopless OS such as our Lite version of Raspberry Pi OS. We call this screenless setup a headless Raspberry Pi. There are different ways to configure a headless Raspberry Pi, here are three : Serial Terminal - This requires extra hardware in the form of a serial-to-USB adapter, but it is by far the most robust way to connect, as you are not relying on any network setup. Ethernet with Static IP Address - This method requires a Linux operating system to change some files on the Raspberry Pi image. You can give the Raspberry Pi a static IP address and then use an Ethernet cable (or WiFi) to log in. WiFi with DHCP - You will need to have access to your router to find your Raspberry Pi's IP address in order to log in via SSH. As a result, this may not be the best option in school or office environments. If you would like to access your Raspberry Pi using the least amount of software work or without network, you will need some extra hardware. Two of the pins on the Raspberry Pi offer transmit and receive data for serial communication. With a small change to a file on the boot sector of the SD card, a command line terminal will be broadcast over this serial line, and you can enter commands to control Linux, write programs, etc. If the other methods do not work to gain access to your Raspberry Pi or you lose your video out signal, using the serial terminal is a great way to see if your Raspberry Pi is still working and to debug any problems you might have. You will need a USB to serial converter for this to work. Enable serial interface and login shell over serial In versions of the Raspberry Pi after 3 (e.g. 3 Model B, 3 Model B+, Zero W), the processor contains two hardware UARTs. One is dedicated to the Bluetooth module, while the other is a less-featured \"mini UART.\" The serial interface is not enabled by default on the board, but we have already enabled it in Lab 1. Warning If Lab 1 made you use raspi-config to enable UART, it may have failed even if your setup was correct. In fact, raspi-config needs a real Raspberry Pi kernel to work well, and QEMU is not sufficient. But good news, most things raspi-config does are just file edits, so we can do it safely manually. We will make sure the serial interface is enabled : Mount the image using sudo losetup -P /dev/loop50 imgs/2024-11-19-raspios-bookworm-arm64-lite.img sudo mount /dev/loop50p2 /mnt/rpi sudo mount /dev/loop50p1 /mnt/rpi/boot Look for a config.txt file in /boot and open it. Now check there is the line enable_uart=1 under the [all] section, if that's not the case add it, save and exit. Unmount the image : sudo umount /mnt/rpi/boot sudo umount /mnt/rpi sudo losetup -d /dev/loop50 The sd-card can now be unmounted from your computer. Choose an Imager We need to choose an imager and download it. Raspberry Pi Imager and Balena Etcher are the go-to imagers. Raspberry Pi Imager is designed for Raspberry Pi users : Easily pick Raspberry Pi OS or other OSes from the app itself. Zero-fuss experience built specifically around Pi usage. Built-in downloads and automatic image selections. Supports writing local image files Balena Etcher offers a broad compatibility and reliability : Write any OS image (Ubuntu, Fedora, RetroPie, custom ISOs, etc.) Verification after writing to reduce corrupted cards Doesn't offer an OS selection in the app, it needs local image file As we are using a custom image, we will use Balena Etcher which is designed to work with custom images and verifies the write integrity to avoid any corruption. Note You could use Raspberry Pi Imager too as it supports writing local image files but it doesn't verify the image after writing. You would prefer using it when you want an official OS for Raspberry Pi and built-in options. Write the image Download the software from the official website: https://etcher.balena.io/ Insert the sd-card in your computer. Warning You might need to use a sd-to-usb adapter if an error occurs when writing the image Finally, launch Balena Etcher and follow the the process to write the image on the sd-card. After a few minutes, the copy should be done and the sd-card ready to be inserted in the Raspberry PI (RPI) board.","title":"A. Writing the Raspberry Pi OS image on the sd-card"},{"location":"image/lab3/writing/#a-writing-the-raspberry-pi-os-image-on-the-sd-card","text":"In this part, we plan to write our Raspberry Pi OS image on a sd-card in order to use it on a real board. Warning Make sure to use the Raspberry Pi OS bookworm image you set up in Lab 1","title":"A. Writing the Raspberry Pi OS image on the sd-card"},{"location":"image/lab3/writing/#headless-raspberry-pi","text":"For convenience or to save space and money, we don't want to use additional hardware components such as a monitor, keyboard, or mouse to access our Raspberry Pi, especially with a desktopless OS such as our Lite version of Raspberry Pi OS. We call this screenless setup a headless Raspberry Pi. There are different ways to configure a headless Raspberry Pi, here are three : Serial Terminal - This requires extra hardware in the form of a serial-to-USB adapter, but it is by far the most robust way to connect, as you are not relying on any network setup. Ethernet with Static IP Address - This method requires a Linux operating system to change some files on the Raspberry Pi image. You can give the Raspberry Pi a static IP address and then use an Ethernet cable (or WiFi) to log in. WiFi with DHCP - You will need to have access to your router to find your Raspberry Pi's IP address in order to log in via SSH. As a result, this may not be the best option in school or office environments. If you would like to access your Raspberry Pi using the least amount of software work or without network, you will need some extra hardware. Two of the pins on the Raspberry Pi offer transmit and receive data for serial communication. With a small change to a file on the boot sector of the SD card, a command line terminal will be broadcast over this serial line, and you can enter commands to control Linux, write programs, etc. If the other methods do not work to gain access to your Raspberry Pi or you lose your video out signal, using the serial terminal is a great way to see if your Raspberry Pi is still working and to debug any problems you might have. You will need a USB to serial converter for this to work.","title":"Headless Raspberry Pi"},{"location":"image/lab3/writing/#enable-serial-interface-and-login-shell-over-serial","text":"In versions of the Raspberry Pi after 3 (e.g. 3 Model B, 3 Model B+, Zero W), the processor contains two hardware UARTs. One is dedicated to the Bluetooth module, while the other is a less-featured \"mini UART.\" The serial interface is not enabled by default on the board, but we have already enabled it in Lab 1. Warning If Lab 1 made you use raspi-config to enable UART, it may have failed even if your setup was correct. In fact, raspi-config needs a real Raspberry Pi kernel to work well, and QEMU is not sufficient. But good news, most things raspi-config does are just file edits, so we can do it safely manually. We will make sure the serial interface is enabled : Mount the image using sudo losetup -P /dev/loop50 imgs/2024-11-19-raspios-bookworm-arm64-lite.img sudo mount /dev/loop50p2 /mnt/rpi sudo mount /dev/loop50p1 /mnt/rpi/boot Look for a config.txt file in /boot and open it. Now check there is the line enable_uart=1 under the [all] section, if that's not the case add it, save and exit. Unmount the image : sudo umount /mnt/rpi/boot sudo umount /mnt/rpi sudo losetup -d /dev/loop50 The sd-card can now be unmounted from your computer.","title":"Enable serial interface and login shell over serial"},{"location":"image/lab3/writing/#choose-an-imager","text":"We need to choose an imager and download it. Raspberry Pi Imager and Balena Etcher are the go-to imagers. Raspberry Pi Imager is designed for Raspberry Pi users : Easily pick Raspberry Pi OS or other OSes from the app itself. Zero-fuss experience built specifically around Pi usage. Built-in downloads and automatic image selections. Supports writing local image files Balena Etcher offers a broad compatibility and reliability : Write any OS image (Ubuntu, Fedora, RetroPie, custom ISOs, etc.) Verification after writing to reduce corrupted cards Doesn't offer an OS selection in the app, it needs local image file As we are using a custom image, we will use Balena Etcher which is designed to work with custom images and verifies the write integrity to avoid any corruption. Note You could use Raspberry Pi Imager too as it supports writing local image files but it doesn't verify the image after writing. You would prefer using it when you want an official OS for Raspberry Pi and built-in options.","title":"Choose an Imager"},{"location":"image/lab3/writing/#write-the-image","text":"Download the software from the official website: https://etcher.balena.io/ Insert the sd-card in your computer. Warning You might need to use a sd-to-usb adapter if an error occurs when writing the image Finally, launch Balena Etcher and follow the the process to write the image on the sd-card. After a few minutes, the copy should be done and the sd-card ready to be inserted in the Raspberry PI (RPI) board.","title":"Write the image"},{"location":"tests/image/clean/","text":"J. Clean chroot Clean your chroot setup : sudo rm /mnt/rpi/etc/resolv.conf sudo umount /mnt/rpi/ { dev/pts,dev,sys,proc,boot, } sudo umount -f /mnt/rpi sudo losetup -d <your_loop_device> Tip If you can't unmount /mnt/rpi because device is busy, use sudo umount -l /mnt/rpi","title":"J. Clean chroot"},{"location":"tests/image/clean/#j-clean-chroot","text":"Clean your chroot setup : sudo rm /mnt/rpi/etc/resolv.conf sudo umount /mnt/rpi/ { dev/pts,dev,sys,proc,boot, } sudo umount -f /mnt/rpi sudo losetup -d <your_loop_device> Tip If you can't unmount /mnt/rpi because device is busy, use sudo umount -l /mnt/rpi","title":"J. Clean chroot"},{"location":"tests/image/git/","text":"A. Git Repository 1. Create the Repository Create a private repository on GitLab named: embsys-ubuntulab Add the teacher ( Tristan LE FLOCH ) as a Reporter member of the project. 2. Clone the Repository On your computer, open a terminal and navigate to the directory where you want to store your work. Create a working directory for this lab: mkdir ubuntulab cd ubuntulab Then clone your repository using: git clone <link_to_your_gitlab_repo> You can then open your local git repo in your preferred IDE or file editor 3. Submit your work Regularly upload your progress to GitLab using standard Git commands: git add git commit git push Note Make sure your online repository always contains the latest version of your work","title":"A. Git Repository"},{"location":"tests/image/git/#a-git-repository","text":"","title":"A. Git Repository"},{"location":"tests/image/git/#1-create-the-repository","text":"Create a private repository on GitLab named: embsys-ubuntulab Add the teacher ( Tristan LE FLOCH ) as a Reporter member of the project.","title":"1. Create the Repository"},{"location":"tests/image/git/#2-clone-the-repository","text":"On your computer, open a terminal and navigate to the directory where you want to store your work. Create a working directory for this lab: mkdir ubuntulab cd ubuntulab Then clone your repository using: git clone <link_to_your_gitlab_repo> You can then open your local git repo in your preferred IDE or file editor","title":"2. Clone the Repository"},{"location":"tests/image/git/#3-submit-your-work","text":"Regularly upload your progress to GitLab using standard Git commands: git add git commit git push Note Make sure your online repository always contains the latest version of your work","title":"3. Submit your work"},{"location":"tests/image/hostname/","text":"D. System Identity Configuration 1. Set the hostname The hostname defines how the robot is identified on the network. Question 1 Choose a meaningful hostname and replace the default one in /etc/hostname . What is the default hostname? /etc/hostname defines the system\u2019s hostname, but many programs also rely on /etc/hosts for local name resolution. Edit /etc/hosts and make sure the line containing 127.0.1.1 matches your hostname. If no such line exists, add one below the 127.0.0.1 localhost line. 2. Set the timezone Robots often operate using UTC time, but you may want to set the timezone to match the robot\u2019s geographic deployment area. Question 2 Use: dpkg-reconfigure tzdata Select the correct geographic area and city. Include a copy of the output in your answers.","title":"D. System Identity Configuration"},{"location":"tests/image/hostname/#d-system-identity-configuration","text":"","title":"D. System Identity Configuration"},{"location":"tests/image/hostname/#1-set-the-hostname","text":"The hostname defines how the robot is identified on the network. Question 1 Choose a meaningful hostname and replace the default one in /etc/hostname . What is the default hostname? /etc/hostname defines the system\u2019s hostname, but many programs also rely on /etc/hosts for local name resolution. Edit /etc/hosts and make sure the line containing 127.0.1.1 matches your hostname. If no such line exists, add one below the 127.0.0.1 localhost line.","title":"1. Set the hostname"},{"location":"tests/image/hostname/#2-set-the-timezone","text":"Robots often operate using UTC time, but you may want to set the timezone to match the robot\u2019s geographic deployment area. Question 2 Use: dpkg-reconfigure tzdata Select the correct geographic area and city. Include a copy of the output in your answers.","title":"2. Set the timezone"},{"location":"tests/image/image/","text":"B. Get the OS Image 1. Our needs First, we need to choose the proper operating system for our application. Let\u2019s start from our requirements: The robot is equipped with a Raspberry Pi 5 , so the OS must be compatible We want an open-source or free Linux-based OS We plan to use ROS 2 libraries and tools to develop our drivers and controllers Question 1 The ROS 2 on Raspberry Pi documentation presents multiple solutions. Which configuration is preferred? Tip Running ROS 2 in Docker on an embedded controller is not the preferred solution, as it adds extra software layers (which can be heavy). It is typically used when Ubuntu cannot be installed directly, or when multiple ROS versions must run side-by-side. There are multiple ROS 2 distributions (versioned sets of ROS packages). How do we choose between them? We do not always select the newest distribution, as it may still be in active development. Instead, we usually choose a LTS (Long-Term Support) distribution. Question 2 Unless our application has specific requirements, we choose the LTS distribution with the latest EOL (End Of Life) date. Which ROS 2 distribution should we use? See: ROS 2 Distributions 2. Choose the OS Ubuntu provides several editions: Ubuntu Desktop Ubuntu Server Ubuntu Core ... Since our target computer is an embedded, headless Raspberry Pi, we do not need a desktop environment. Ubuntu Server is lightweight and runs without a graphical interface, which saves computing resources on an embedded system. It is designed for reliable headless operation over SSH, which matches how robots are accessed and managed in the field. It is also widely supported by robotics tools such as ROS, making software integration easier. Therefore, we will use Ubuntu Server . Next, there are two main ways to install ROS 2: Using precompiled binary packages Building from source We will install ROS 2 using the official binary packages in order to get a working setup quickly. However, ROS 2 binary packages are only provided for specific Ubuntu versions. Question 3 What is the target Ubuntu version for your chosen ROS 2 distribution? Find this information on the installation page for your ROS 2 distribution. Tip Ubuntu 20.04, 22.04, 24.04, 25.10 3. Download the OS Image Place yourself in the ubuntulab folder Ubuntu Server images for Raspberry Pi are available here: Install Ubuntu on a Raspberry Pi Look for the proper Ubuntu version either on the default installer or in the archives: Ubuntu releases . Warning If you search your version in the archives, make sure to choose the Raspberry Pi preinstalled Server image. Download Ubuntu Server. You must obtain a .img.xz file. Move the file in ubuntulab Warning Don't save your image in your local git repo or use a .gitignore so you don't push it online, as it is heavy and unecessary. Question 4 Decompress the xz file with the xz command 4. Increase the size of the .img file Question 4 Check your image and partitions sizes with fdisk -l Later, we will install ROS2 on our image but we see that our img is only a bit larger than 3G which is too small for system files and ROS2 installation. Let's increase it to 8G : sudo truncate -s 8G <your_.img_file> Warning It requires some space on your computer The image has been resized but not he partition. Now use fdisk to resize the root partition sudo fdisk <your_image> Inside fdisk: Press p \u2192 see current partitions Note start sector of partition 2 (in our case, it is probably 1050624) Press d \u2192 delete partition 2 (don\u2019t worry, data is safe because we will recreate it at the same start sector) Press n \u2192 new partition Type primary (p) Partition number: 2 First sector: 1050624 (must be same as before!) Last sector: accept default (fill the image) Press w \u2192 write changes Check your partitions sizes again. It must have increased. Tip You can delete the .img file after you completely finished the lab","title":"B. Get the OS Image"},{"location":"tests/image/image/#b-get-the-os-image","text":"","title":"B. Get the OS Image"},{"location":"tests/image/image/#1-our-needs","text":"First, we need to choose the proper operating system for our application. Let\u2019s start from our requirements: The robot is equipped with a Raspberry Pi 5 , so the OS must be compatible We want an open-source or free Linux-based OS We plan to use ROS 2 libraries and tools to develop our drivers and controllers Question 1 The ROS 2 on Raspberry Pi documentation presents multiple solutions. Which configuration is preferred? Tip Running ROS 2 in Docker on an embedded controller is not the preferred solution, as it adds extra software layers (which can be heavy). It is typically used when Ubuntu cannot be installed directly, or when multiple ROS versions must run side-by-side. There are multiple ROS 2 distributions (versioned sets of ROS packages). How do we choose between them? We do not always select the newest distribution, as it may still be in active development. Instead, we usually choose a LTS (Long-Term Support) distribution. Question 2 Unless our application has specific requirements, we choose the LTS distribution with the latest EOL (End Of Life) date. Which ROS 2 distribution should we use? See: ROS 2 Distributions","title":"1. Our needs"},{"location":"tests/image/image/#2-choose-the-os","text":"Ubuntu provides several editions: Ubuntu Desktop Ubuntu Server Ubuntu Core ... Since our target computer is an embedded, headless Raspberry Pi, we do not need a desktop environment. Ubuntu Server is lightweight and runs without a graphical interface, which saves computing resources on an embedded system. It is designed for reliable headless operation over SSH, which matches how robots are accessed and managed in the field. It is also widely supported by robotics tools such as ROS, making software integration easier. Therefore, we will use Ubuntu Server . Next, there are two main ways to install ROS 2: Using precompiled binary packages Building from source We will install ROS 2 using the official binary packages in order to get a working setup quickly. However, ROS 2 binary packages are only provided for specific Ubuntu versions. Question 3 What is the target Ubuntu version for your chosen ROS 2 distribution? Find this information on the installation page for your ROS 2 distribution. Tip Ubuntu 20.04, 22.04, 24.04, 25.10","title":"2. Choose the OS"},{"location":"tests/image/image/#3-download-the-os-image","text":"Place yourself in the ubuntulab folder Ubuntu Server images for Raspberry Pi are available here: Install Ubuntu on a Raspberry Pi Look for the proper Ubuntu version either on the default installer or in the archives: Ubuntu releases . Warning If you search your version in the archives, make sure to choose the Raspberry Pi preinstalled Server image. Download Ubuntu Server. You must obtain a .img.xz file. Move the file in ubuntulab Warning Don't save your image in your local git repo or use a .gitignore so you don't push it online, as it is heavy and unecessary. Question 4 Decompress the xz file with the xz command","title":"3. Download the OS Image"},{"location":"tests/image/image/#4-increase-the-size-of-the-img-file","text":"Question 4 Check your image and partitions sizes with fdisk -l Later, we will install ROS2 on our image but we see that our img is only a bit larger than 3G which is too small for system files and ROS2 installation. Let's increase it to 8G : sudo truncate -s 8G <your_.img_file> Warning It requires some space on your computer The image has been resized but not he partition. Now use fdisk to resize the root partition sudo fdisk <your_image> Inside fdisk: Press p \u2192 see current partitions Note start sector of partition 2 (in our case, it is probably 1050624) Press d \u2192 delete partition 2 (don\u2019t worry, data is safe because we will recreate it at the same start sector) Press n \u2192 new partition Type primary (p) Partition number: 2 First sector: 1050624 (must be same as before!) Last sector: accept default (fill the image) Press w \u2192 write changes Check your partitions sizes again. It must have increased. Tip You can delete the .img file after you completely finished the lab","title":"4. Increase the size of the .img file"},{"location":"tests/image/intro/","text":"Introduction Goal of the lab Practice on embedded Linux images Prepare an embedded Linux image from your computer for a real robot Application In this lab, you will act as a robotics engineer preparing the onboard computer of an Autonomous Underwater Vehicle (AUV) : the SEABOT Modern robots \u2014 especially mobile and marine robots \u2014 rely on small embedded computers such as the Raspberry Pi to run their software stack. These computers must be carefully prepared before deployment: the operating system needs to be installed, configured for headless operation, secured, networked, and equipped with the essential tools required for robotics development. Instead of working directly on the physical robot, you will simulate this real-world workflow by: Creating a bootable Ubuntu Server image Configuring it from your personal computer Preparing the Operating System as if it were going to be deployed inside an AUV Note In this exercise, we work only on the main board of the robot which is a Raspberry Pi 5 Assessment Your work will be evaluated based on your ability to correctly prepare, configure, and document an embedded Ubuntu Server system suitable for robotic deployment. You are expected to demonstrate: Proper installation of the Ubuntu Server image Proper mount and access to the image partitions from your computer Correct system configuration (users, hostname, networking, SSH, etc.) Installation of required software tools Clear documentation of your steps and reasoning Submit your work via a Git repository containing: A README.md written in Markdown containing answers to questions and used commands. Configuration files, scripts, or command logs when asked Your documentation should be clear enough that another robotics engineer could reproduce your system from scratch. The git clarity will count in the notation. Warning This assessment is due by Sunday, February 1st","title":"Introduction"},{"location":"tests/image/intro/#introduction","text":"","title":"Introduction"},{"location":"tests/image/intro/#goal-of-the-lab","text":"Practice on embedded Linux images Prepare an embedded Linux image from your computer for a real robot","title":"Goal of the lab"},{"location":"tests/image/intro/#application","text":"In this lab, you will act as a robotics engineer preparing the onboard computer of an Autonomous Underwater Vehicle (AUV) : the SEABOT Modern robots \u2014 especially mobile and marine robots \u2014 rely on small embedded computers such as the Raspberry Pi to run their software stack. These computers must be carefully prepared before deployment: the operating system needs to be installed, configured for headless operation, secured, networked, and equipped with the essential tools required for robotics development. Instead of working directly on the physical robot, you will simulate this real-world workflow by: Creating a bootable Ubuntu Server image Configuring it from your personal computer Preparing the Operating System as if it were going to be deployed inside an AUV Note In this exercise, we work only on the main board of the robot which is a Raspberry Pi 5","title":"Application"},{"location":"tests/image/intro/#assessment","text":"Your work will be evaluated based on your ability to correctly prepare, configure, and document an embedded Ubuntu Server system suitable for robotic deployment. You are expected to demonstrate: Proper installation of the Ubuntu Server image Proper mount and access to the image partitions from your computer Correct system configuration (users, hostname, networking, SSH, etc.) Installation of required software tools Clear documentation of your steps and reasoning Submit your work via a Git repository containing: A README.md written in Markdown containing answers to questions and used commands. Configuration files, scripts, or command logs when asked Your documentation should be clear enough that another robotics engineer could reproduce your system from scratch. The git clarity will count in the notation. Warning This assessment is due by Sunday, February 1st","title":"Assessment"},{"location":"tests/image/modif/","text":"C. Modifying the Image 1. Method Choice You downloaded a preinstalled Ubuntu Server image for Raspberry Pi: ubuntu-<version_number>-preinstalled-server-arm64+raspi.img This image is built for an ARM64 processor , while your computer likely uses an x86_64 (amd64) CPU. Because of this architecture difference, the image cannot run natively on your PC. To configure it anyway, we must emulate an ARM system. There are two main methods: Method 1 \u2014 Modify the Image Using chroot + QEMU (Lightweight, Fast) This method allows you to enter the Raspberry Pi filesystem directly from your PC and run ARM programs using CPU emulation. Principle: Mount the .img file as a disk Access its Linux filesystem Use QEMU user emulation to run ARM binaries Enter the system using chroot Configure it like a real Raspberry Pi OS Pros: Fast \u2014 no full system boot Lightweight \u2014 no virtual machine overhead Directly edits the real SD card image Cons: Not a fully booted system Hardware-related services will not function For headless Raspberry Pi preparation, this method is ideal. It is the most realistic embedded Linux preparation workflow used in robotics and industry. Method 2 \u2014 Boot the Image in a Full QEMU Virtual Machine (Heavier, More Realistic) Instead of modifying files directly, you can emulate a full Raspberry Pi\u2013like machine and boot the image. Principle: QEMU emulates ARM hardware The .img file is used as the virtual SD card You interact with the system as if it were a real Pi (terminal login) Pros: Real boot process systemd runs normally Cons: Slow Complex setup Raspberry Pi images do not always boot cleanly in generic QEMU without kernel modifications The emulated hardware may not exactly match the real device We use a QEMU VM when we need a fully booted system, for example to test: Boot errors Service startup issues Login behavior Networking configuration 2. Setup the Image for chroot The following steps are similar to those performed in Lab 1. Warning Do not reuse your start_chroot.sh and stop_chroot.sh scripts from Lab 1. Some steps differ in this lab, and using the old scripts may cause errors. Question 1 Attach the image as a loop device using losetup , using options that allow you to: Create a partitioned loop device Automatically select the first free loop device Print the device name after setup Question 2 Mount the root filesystem partition Use lsblk to identify which partition from your newly created loop device is the largest \u2014 this is the root filesystem (copy the output in your answer file). It will look like /dev/loopXp1 or /dev/loopXp2 . Create a mount point: sudo mkdir -p /mnt/rpi Mount the root filesystem partition at /mnt/rpi . On Ubuntu for Raspberry Pi, the FAT boot partition is mounted at /boot/firmware , not /boot . Ubuntu separates: /boot \u2192 Linux kernel, initrd, and bootloader files managed by Ubuntu packages /boot/firmware \u2192 Raspberry Pi firmware partition (FAT) containing files such as config.txt , cmdline.txt , start*.elf , etc. When preparing the image offline, mount the boot partition at /mnt/rpi/boot/firmware so it matches the layout expected at runtime. Tip If the firmware folder does not exist inside /mnt/rpi/boot , create it: sudo mkdir -p /mnt/rpi/boot/firmware Question 3 Mount the boot partition at /mnt/rpi/boot/firmware . Do not forget to mount system directories (required for chroot ): sudo mount --bind /dev /mnt/rpi/dev sudo mount --bind /dev/pts /mnt/rpi/dev/pts sudo mount --bind /proc /mnt/rpi/proc sudo mount --bind /sys /mnt/rpi/sys Note If you get PTY errors, restart your PC and try instead : sudo mount --bind /dev /mnt/rpi/dev/ sudo mount --bind /sys /mnt/rpi/sys/ sudo mount --bind /proc /mnt/rpi/proc/ sudo mount -t devpts devpts /mnt/rpi/dev/pts If the error persists, try omitting the /mnt/rpi/dev/pts mount. Then, Enable ARM emulation inside the image with QEMU : sudo cp /usr/bin/qemu-aarch64-static /mnt/rpi/usr/bin/ Finally, bind your host\u2019s /etc/resolv.conf inside the chroot : sudo cp /etc/resolv.conf /mnt/rpi/etc/resolv.conf It will allow to access internet through the host in chroot. Tip You may want to group the previous steps into a bash script to execute them in a single command, as you did in Lab 1. Finally, the setup is done and we are ready to run chroot Question 4 Enter the Raspberry Pi system using chroot Test the emulation is working using uname -m It should return aarch64 .","title":"C. Modifying the Image"},{"location":"tests/image/modif/#c-modifying-the-image","text":"","title":"C. Modifying the Image"},{"location":"tests/image/modif/#1-method-choice","text":"You downloaded a preinstalled Ubuntu Server image for Raspberry Pi: ubuntu-<version_number>-preinstalled-server-arm64+raspi.img This image is built for an ARM64 processor , while your computer likely uses an x86_64 (amd64) CPU. Because of this architecture difference, the image cannot run natively on your PC. To configure it anyway, we must emulate an ARM system. There are two main methods:","title":"1. Method Choice"},{"location":"tests/image/modif/#method-1-modify-the-image-using-chroot-qemu-lightweight-fast","text":"This method allows you to enter the Raspberry Pi filesystem directly from your PC and run ARM programs using CPU emulation. Principle: Mount the .img file as a disk Access its Linux filesystem Use QEMU user emulation to run ARM binaries Enter the system using chroot Configure it like a real Raspberry Pi OS Pros: Fast \u2014 no full system boot Lightweight \u2014 no virtual machine overhead Directly edits the real SD card image Cons: Not a fully booted system Hardware-related services will not function For headless Raspberry Pi preparation, this method is ideal. It is the most realistic embedded Linux preparation workflow used in robotics and industry.","title":"Method 1 \u2014 Modify the Image Using chroot + QEMU (Lightweight, Fast)"},{"location":"tests/image/modif/#method-2-boot-the-image-in-a-full-qemu-virtual-machine-heavier-more-realistic","text":"Instead of modifying files directly, you can emulate a full Raspberry Pi\u2013like machine and boot the image. Principle: QEMU emulates ARM hardware The .img file is used as the virtual SD card You interact with the system as if it were a real Pi (terminal login) Pros: Real boot process systemd runs normally Cons: Slow Complex setup Raspberry Pi images do not always boot cleanly in generic QEMU without kernel modifications The emulated hardware may not exactly match the real device We use a QEMU VM when we need a fully booted system, for example to test: Boot errors Service startup issues Login behavior Networking configuration","title":"Method 2 \u2014 Boot the Image in a Full QEMU Virtual Machine (Heavier, More Realistic)"},{"location":"tests/image/modif/#2-setup-the-image-for-chroot","text":"The following steps are similar to those performed in Lab 1. Warning Do not reuse your start_chroot.sh and stop_chroot.sh scripts from Lab 1. Some steps differ in this lab, and using the old scripts may cause errors. Question 1 Attach the image as a loop device using losetup , using options that allow you to: Create a partitioned loop device Automatically select the first free loop device Print the device name after setup Question 2 Mount the root filesystem partition Use lsblk to identify which partition from your newly created loop device is the largest \u2014 this is the root filesystem (copy the output in your answer file). It will look like /dev/loopXp1 or /dev/loopXp2 . Create a mount point: sudo mkdir -p /mnt/rpi Mount the root filesystem partition at /mnt/rpi . On Ubuntu for Raspberry Pi, the FAT boot partition is mounted at /boot/firmware , not /boot . Ubuntu separates: /boot \u2192 Linux kernel, initrd, and bootloader files managed by Ubuntu packages /boot/firmware \u2192 Raspberry Pi firmware partition (FAT) containing files such as config.txt , cmdline.txt , start*.elf , etc. When preparing the image offline, mount the boot partition at /mnt/rpi/boot/firmware so it matches the layout expected at runtime. Tip If the firmware folder does not exist inside /mnt/rpi/boot , create it: sudo mkdir -p /mnt/rpi/boot/firmware Question 3 Mount the boot partition at /mnt/rpi/boot/firmware . Do not forget to mount system directories (required for chroot ): sudo mount --bind /dev /mnt/rpi/dev sudo mount --bind /dev/pts /mnt/rpi/dev/pts sudo mount --bind /proc /mnt/rpi/proc sudo mount --bind /sys /mnt/rpi/sys Note If you get PTY errors, restart your PC and try instead : sudo mount --bind /dev /mnt/rpi/dev/ sudo mount --bind /sys /mnt/rpi/sys/ sudo mount --bind /proc /mnt/rpi/proc/ sudo mount -t devpts devpts /mnt/rpi/dev/pts If the error persists, try omitting the /mnt/rpi/dev/pts mount. Then, Enable ARM emulation inside the image with QEMU : sudo cp /usr/bin/qemu-aarch64-static /mnt/rpi/usr/bin/ Finally, bind your host\u2019s /etc/resolv.conf inside the chroot : sudo cp /etc/resolv.conf /mnt/rpi/etc/resolv.conf It will allow to access internet through the host in chroot. Tip You may want to group the previous steps into a bash script to execute them in a single command, as you did in Lab 1. Finally, the setup is done and we are ready to run chroot Question 4 Enter the Raspberry Pi system using chroot Test the emulation is working using uname -m It should return aarch64 .","title":"2. Setup the Image for chroot"},{"location":"tests/image/network/","text":"F. Network Configuration 1. Netplan Ubuntu Server uses Netplan for networking. Network configuration files are located in /etc/netplan . On Ubuntu preinstalled Raspberry Pi images, this directory may be empty because networking is sometimes generated by cloud-init on first boot. Since we are preparing the system offline in a chroot environment, we need to create our own Netplan configuration file. Create a Netplan file: nano /etc/netplan/01-netcfg.yaml 2. Wifi configuration Our objective is to operate a swarm of 20 Seabots. To make them easily accessible via SSH, we use a dedicated Seabot Access Point (AP) and assign static IP addresses to the robots based on their ID number (from 01 to 20). Let's state the WI-Fi network parameters : SSID : seabot-ap no password Network : 192.168.0.0/24 Access Point IP (gateway) : 192.168.0.1 The netplan file can be completed as follows : network: version: 2 renderer: networkd wifis: wlan0: dhcp4: no addresses: - 192 .168.0.1<seabot_id>/24 routes: - to: default via: 192 .168.0.1 nameservers: addresses: [ 8 .8.8.8, 1 .1.1.1 ] access-points: \"seabot-ap\" : password: \"\" 3. Ethernet configuration Our robot is equipped with a hydrophone and collects large volumes of acoustic data. These datasets are too large to transfer efficiently over Wi-Fi, so we use Ethernet for high-speed data retrieval. To simplify direct connection to a laptop, we assign a static Ethernet IP to each robot. Add the following Ethernet configuration to the same Netplan file: ethernets: eth0: dhcp4: no addresses: - 192 .168.1.1<seabot_id>/24 Note No gateway is needed on Ethernet because this link is only used for direct communication with a laptop, not for internet access. Question 1 Edit the netplan file for seabot number 12 : The configuration will be applied automatically when the Raspberry Pi boots.","title":"F. Network Configuration"},{"location":"tests/image/network/#f-network-configuration","text":"","title":"F. Network Configuration"},{"location":"tests/image/network/#1-netplan","text":"Ubuntu Server uses Netplan for networking. Network configuration files are located in /etc/netplan . On Ubuntu preinstalled Raspberry Pi images, this directory may be empty because networking is sometimes generated by cloud-init on first boot. Since we are preparing the system offline in a chroot environment, we need to create our own Netplan configuration file. Create a Netplan file: nano /etc/netplan/01-netcfg.yaml","title":"1. Netplan"},{"location":"tests/image/network/#2-wifi-configuration","text":"Our objective is to operate a swarm of 20 Seabots. To make them easily accessible via SSH, we use a dedicated Seabot Access Point (AP) and assign static IP addresses to the robots based on their ID number (from 01 to 20). Let's state the WI-Fi network parameters : SSID : seabot-ap no password Network : 192.168.0.0/24 Access Point IP (gateway) : 192.168.0.1 The netplan file can be completed as follows : network: version: 2 renderer: networkd wifis: wlan0: dhcp4: no addresses: - 192 .168.0.1<seabot_id>/24 routes: - to: default via: 192 .168.0.1 nameservers: addresses: [ 8 .8.8.8, 1 .1.1.1 ] access-points: \"seabot-ap\" : password: \"\"","title":"2. Wifi configuration"},{"location":"tests/image/network/#3-ethernet-configuration","text":"Our robot is equipped with a hydrophone and collects large volumes of acoustic data. These datasets are too large to transfer efficiently over Wi-Fi, so we use Ethernet for high-speed data retrieval. To simplify direct connection to a laptop, we assign a static Ethernet IP to each robot. Add the following Ethernet configuration to the same Netplan file: ethernets: eth0: dhcp4: no addresses: - 192 .168.1.1<seabot_id>/24 Note No gateway is needed on Ethernet because this link is only used for direct communication with a laptop, not for internet access. Question 1 Edit the netplan file for seabot number 12 : The configuration will be applied automatically when the Raspberry Pi boots.","title":"3. Ethernet configuration"},{"location":"tests/image/qemu/","text":"H. Use QEMU VM (optionnal) Warning NOT TESTED You can try to emulate a Raspberry Pi with your image using QEMU VM. Thus, you can verify your hostname, network, systemd, etc configurations work.","title":"H. Use QEMU VM (optionnal)"},{"location":"tests/image/qemu/#h-use-qemu-vm-optionnal","text":"Warning NOT TESTED You can try to emulate a Raspberry Pi with your image using QEMU VM. Thus, you can verify your hostname, network, systemd, etc configurations work.","title":"H. Use QEMU VM (optionnal)"},{"location":"tests/image/ros2/","text":"G. ROS 2 Setup Now, let's install ROS 2. Remember: we can execute commands inside the image and use our PC\u2019s shared internet access. For example, update the package index: sudo apt update Warning As we are emulating an arm64 archietcture from an x86_64 architecure, these steps may be quite long. Skip the nex ROS2 installation to save time. We will install ROS 2 binary packages inside the chroot. This is simpler and faster than building from source. Follow the ROS 2 documentation corresponding to your chosen ROS 2 distribution to install ROS 2 using deb packages . You will have to choose between the Desktop Install and the ROS-Base Install . Since we are setting up a headless Raspberry Pi, GUI tools are not required, so select the minimal ROS-Base install . Warning You might get uninstallable packages errors. That's a reported issue with Jazzy on Ubuntu 24.04.3. If this occurs try this solution from github (not tested), but you might need to extend your image size a bit more Or try building ros from source.","title":"G. ROS 2 Setup"},{"location":"tests/image/ros2/#g-ros-2-setup","text":"Now, let's install ROS 2. Remember: we can execute commands inside the image and use our PC\u2019s shared internet access. For example, update the package index: sudo apt update Warning As we are emulating an arm64 archietcture from an x86_64 architecure, these steps may be quite long. Skip the nex ROS2 installation to save time. We will install ROS 2 binary packages inside the chroot. This is simpler and faster than building from source. Follow the ROS 2 documentation corresponding to your chosen ROS 2 distribution to install ROS 2 using deb packages . You will have to choose between the Desktop Install and the ROS-Base Install . Since we are setting up a headless Raspberry Pi, GUI tools are not required, so select the minimal ROS-Base install . Warning You might get uninstallable packages errors. That's a reported issue with Jazzy on Ubuntu 24.04.3. If this occurs try this solution from github (not tested), but you might need to extend your image size a bit more Or try building ros from source.","title":"G. ROS 2 Setup"},{"location":"tests/image/service/","text":"I. Systemd service When operating on field, we don't want to loose time with the whole process of connecting to the robot and launching the programs. To avoid it, we want the robot to launch its program automatically at boot. For this lab we will launch a simple python script, but with ROS2 you could launch all your nodes at boot ! 1. Create a simple python script Question Create a python script named boot_script.py in the user\u2019s home directory, that simply prints \"Seabot operating\" every 2s. Execute it with python3 to check it works. 2. Create a systemd service file systemd is the init system in modern Linux. It manages: Starting and stopping services at boot Dependencies between services Logging and restarting on failure A systemd service is basically a unit file that tells Linux: What program to run When to run it Under which user Restart behavior if it fails Step 1: make the script executable Here my user is pi , replace by yours chmod +x /home/pi/boot_script.py Step 2: Create the service file Systemd service files go in /etc/systemd/system/ Question 2 Create a boot_script.service file in /etc/systemd/system/ Put this content in the file : [ Unit ] Description = Boot Python Script [ Service ] Type = simple ExecStart = /usr/bin/python3 /home/pi/boot_script.py WorkingDirectory = /home/pi User = pi Restart = on-failure [ Install ] WantedBy = multi-user.target Explanation of fields : Field Meaning Description Human-readable description of the service Type=simple Standard service that runs continuously ExecStart Command to execute WorkingDirectory Directory from which the script runs User Runs as this user instead of root Restart=on-failure Automatically restarts if it crashes WantedBy=multi-user.target Starts at normal multi-user boot Step 3: Enable and start the service sudo systemctl daemon-reload # reload systemd to detect new service sudo systemctl enable boot_script # enable at boot sudo systemctl start boot_script # start now The start command won't work as we are in chroot but the service will start when booting on a reak board.","title":"I. Systemd service"},{"location":"tests/image/service/#i-systemd-service","text":"When operating on field, we don't want to loose time with the whole process of connecting to the robot and launching the programs. To avoid it, we want the robot to launch its program automatically at boot. For this lab we will launch a simple python script, but with ROS2 you could launch all your nodes at boot !","title":"I. Systemd service"},{"location":"tests/image/service/#1-create-a-simple-python-script","text":"Question Create a python script named boot_script.py in the user\u2019s home directory, that simply prints \"Seabot operating\" every 2s. Execute it with python3 to check it works.","title":"1. Create a simple python script"},{"location":"tests/image/service/#2-create-a-systemd-service-file","text":"systemd is the init system in modern Linux. It manages: Starting and stopping services at boot Dependencies between services Logging and restarting on failure A systemd service is basically a unit file that tells Linux: What program to run When to run it Under which user Restart behavior if it fails","title":"2. Create a systemd service file"},{"location":"tests/image/service/#step-1-make-the-script-executable","text":"Here my user is pi , replace by yours chmod +x /home/pi/boot_script.py","title":"Step 1: make the script executable"},{"location":"tests/image/service/#step-2-create-the-service-file","text":"Systemd service files go in /etc/systemd/system/ Question 2 Create a boot_script.service file in /etc/systemd/system/ Put this content in the file : [ Unit ] Description = Boot Python Script [ Service ] Type = simple ExecStart = /usr/bin/python3 /home/pi/boot_script.py WorkingDirectory = /home/pi User = pi Restart = on-failure [ Install ] WantedBy = multi-user.target Explanation of fields : Field Meaning Description Human-readable description of the service Type=simple Standard service that runs continuously ExecStart Command to execute WorkingDirectory Directory from which the script runs User Runs as this user instead of root Restart=on-failure Automatically restarts if it crashes WantedBy=multi-user.target Starts at normal multi-user boot","title":"Step 2: Create the service file"},{"location":"tests/image/service/#step-3-enable-and-start-the-service","text":"sudo systemctl daemon-reload # reload systemd to detect new service sudo systemctl enable boot_script # enable at boot sudo systemctl start boot_script # start now The start command won't work as we are in chroot but the service will start when booting on a reak board.","title":"Step 3: Enable and start the service"},{"location":"tests/image/udev/","text":"H. Udev Rules \u2014 Hardware Access 1. What are udev rules ? udev is the device manager for Linux. It controls: How hardware devices appear in /dev Who can access them What permissions are set when a device is plugged in On a robot, many sensors are connected via USB, serial, or other interfaces. By default, you often need root access to read/write to these devices. Using udev rules, you can: Assign permissions to a device for a specific user or group Give the robot software automatic access to hardware without needing sudo Name devices consistently, e.g., /dev/gnss0 or /dev/hydrophone This is essential for embedded robotics: the robot must access its sensors automatically at boot, without manual intervention. 2. Create a udev rule In order to avoid hitting the seafloor when regulating its depth, the Seabot is equipped with a Ping Sonar Altimeter and Echosounder from Blue Robotics. We will create a udev rule for it. Step 1: Identify the device If you had a real device, you would first plug it in and find it with: ls /dev/tty* Let's assume the device appears as /dev/ttyUSB0. Then check its vendor and product IDs (won\u2019t work here since we don\u2019t have the device): udevadm info -a -n /dev/ttyUSB0 We will look for lines like : ATTRS { idVendor }== \"1234\" ATTRS { idProduct }== \"5678\" For this lab, assume we got the following IDs: Vendor ID : 4896 Product ID : 7912 Step 2: Create the rule file udev rules files are stored in /etc/udev/rules.d/ Question 1 Create a 99-seabot.rules udev file Step 3: Add a rule Every time the Raspberry Pi detects a device with the echosounder\u2019s vendor and product IDs, it will: - Give users in the dialout group access to it - Give read/write permissions for everyone - Create a symlink named ping1D pointing to the device Add the following line in the udev file: SUBSYSTEM == \"tty\" , ATTRS { idVendor }== \"<vendor_id>\" , ATTRS { idProduct }== \"<product_id>\" , SYMLINK += \"<new_device_name>\" , GROUP = \"dialout\" , MODE = \"0666\" Field Meaning SUBSYSTEM==\"tty\" Apply to serial/USB devices ATTRS{idVendor} Vendor ID of the device ATTRS{idProduct} Product ID of the device SYMLINK+= Symlink name to the device GROUP=\"dialout\" Users in dialout group can access MODE=\"0666\" Read/write permissions for everyone Question 2 Edit the udev file to create the rule for the echosounder. Show your line in your answers.","title":"H. Udev Rules \u2014 Hardware Access"},{"location":"tests/image/udev/#h-udev-rules-hardware-access","text":"","title":"H. Udev Rules \u2014 Hardware Access"},{"location":"tests/image/udev/#1-what-are-udev-rules","text":"udev is the device manager for Linux. It controls: How hardware devices appear in /dev Who can access them What permissions are set when a device is plugged in On a robot, many sensors are connected via USB, serial, or other interfaces. By default, you often need root access to read/write to these devices. Using udev rules, you can: Assign permissions to a device for a specific user or group Give the robot software automatic access to hardware without needing sudo Name devices consistently, e.g., /dev/gnss0 or /dev/hydrophone This is essential for embedded robotics: the robot must access its sensors automatically at boot, without manual intervention.","title":"1. What are udev rules?"},{"location":"tests/image/udev/#2-create-a-udev-rule","text":"In order to avoid hitting the seafloor when regulating its depth, the Seabot is equipped with a Ping Sonar Altimeter and Echosounder from Blue Robotics. We will create a udev rule for it.","title":"2. Create a udev rule"},{"location":"tests/image/udev/#step-1-identify-the-device","text":"If you had a real device, you would first plug it in and find it with: ls /dev/tty* Let's assume the device appears as /dev/ttyUSB0. Then check its vendor and product IDs (won\u2019t work here since we don\u2019t have the device): udevadm info -a -n /dev/ttyUSB0 We will look for lines like : ATTRS { idVendor }== \"1234\" ATTRS { idProduct }== \"5678\" For this lab, assume we got the following IDs: Vendor ID : 4896 Product ID : 7912","title":"Step 1: Identify the device"},{"location":"tests/image/udev/#step-2-create-the-rule-file","text":"udev rules files are stored in /etc/udev/rules.d/ Question 1 Create a 99-seabot.rules udev file","title":"Step 2: Create the rule file"},{"location":"tests/image/udev/#step-3-add-a-rule","text":"Every time the Raspberry Pi detects a device with the echosounder\u2019s vendor and product IDs, it will: - Give users in the dialout group access to it - Give read/write permissions for everyone - Create a symlink named ping1D pointing to the device Add the following line in the udev file: SUBSYSTEM == \"tty\" , ATTRS { idVendor }== \"<vendor_id>\" , ATTRS { idProduct }== \"<product_id>\" , SYMLINK += \"<new_device_name>\" , GROUP = \"dialout\" , MODE = \"0666\" Field Meaning SUBSYSTEM==\"tty\" Apply to serial/USB devices ATTRS{idVendor} Vendor ID of the device ATTRS{idProduct} Product ID of the device SYMLINK+= Symlink name to the device GROUP=\"dialout\" Users in dialout group can access MODE=\"0666\" Read/write permissions for everyone Question 2 Edit the udev file to create the rule for the echosounder. Show your line in your answers.","title":"Step 3: Add a rule"},{"location":"tests/image/user/","text":"E. User configuration Let\u2019s prepare access to the robot before its first boot. 1. Create a new user Check if a default user already exists: ls /home f this command returns nothing, there is no default user. Question 1 Create a new user with a name of your choice and set a password. You may leave the optional user information fields empty. Tip Make sure you remember the password you choose. You may use a simple password for the lab, but never do this on a real robot connected to a network. Tip You can change a user\u2019s password later using: passwd 2. Give sudo privileges On Ubuntu, you can grant sudo privileges to your user with: usermod -aG sudo <username> 3. Add user to hardware-related groups Our robot is a depth-controlled float designed to operate in open water for extended periods. At the end of its mission, the robot surfaces, acquires a GNSS signal, and transmits its position over radio so it can be recovered. The GNSS module is connected to a serial port on the Raspberry Pi. To allow your user to read data from this serial port, the user must belong to the appropriate system group. Question 2 Add your newly created user to the dialout group. Tip The command is very similar to the one used for adding a user to the sudo group.","title":"E. User configuration"},{"location":"tests/image/user/#e-user-configuration","text":"Let\u2019s prepare access to the robot before its first boot.","title":"E. User configuration"},{"location":"tests/image/user/#1-create-a-new-user","text":"Check if a default user already exists: ls /home f this command returns nothing, there is no default user. Question 1 Create a new user with a name of your choice and set a password. You may leave the optional user information fields empty. Tip Make sure you remember the password you choose. You may use a simple password for the lab, but never do this on a real robot connected to a network. Tip You can change a user\u2019s password later using: passwd","title":"1. Create a new user"},{"location":"tests/image/user/#2-give-sudo-privileges","text":"On Ubuntu, you can grant sudo privileges to your user with: usermod -aG sudo <username>","title":"2. Give sudo privileges"},{"location":"tests/image/user/#3-add-user-to-hardware-related-groups","text":"Our robot is a depth-controlled float designed to operate in open water for extended periods. At the end of its mission, the robot surfaces, acquires a GNSS signal, and transmits its position over radio so it can be recovered. The GNSS module is connected to a serial port on the Raspberry Pi. To allow your user to read data from this serial port, the user must belong to the appropriate system group. Question 2 Add your newly created user to the dialout group. Tip The command is very similar to the one used for adding a user to the sudo group.","title":"3. Add user to hardware-related groups"}]}