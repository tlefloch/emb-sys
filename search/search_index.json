{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Embedded Systems course Definition An embedded system is a specialized computer system\u2014a combination of a computer processor, computer memory, and input/output peripheral devices\u2014that has a dedicated function within a larger mechanical or electronic system. It is embedded as part of a complete device often including electrical or electronic hardware and mechanical parts. Because an embedded system typically controls physical operations of the machine that it is embedded within, it often has real-time computing constraints. @Wikipedia Objectives The main objective of this course is to learn how to create your own embedded image of Operating System (OS) Subjects include : the configuration of the network interface of an embedded system how to test and modify the embedded OS directly on your host machine (QEMU, mounting, etc) containerization (Docker) References Most of the content of this course was written by Beno\u00eet Zerr, the previous teacher, and is based on his slides.","title":"Home"},{"location":"#welcome-to-the-embedded-systems-course","text":"","title":"Welcome to the Embedded Systems course"},{"location":"#definition","text":"An embedded system is a specialized computer system\u2014a combination of a computer processor, computer memory, and input/output peripheral devices\u2014that has a dedicated function within a larger mechanical or electronic system. It is embedded as part of a complete device often including electrical or electronic hardware and mechanical parts. Because an embedded system typically controls physical operations of the machine that it is embedded within, it often has real-time computing constraints. @Wikipedia","title":"Definition"},{"location":"#objectives","text":"The main objective of this course is to learn how to create your own embedded image of Operating System (OS) Subjects include : the configuration of the network interface of an embedded system how to test and modify the embedded OS directly on your host machine (QEMU, mounting, etc) containerization (Docker)","title":"Objectives"},{"location":"#references","text":"Most of the content of this course was written by Beno\u00eet Zerr, the previous teacher, and is based on his slides.","title":"References"},{"location":"image/qemu/","text":"Introduction to QEMU Introduction QEMU , which stands for Quick Emulator , is an open-source software project that provides an emulation and virtualization framework. It is designed to run a variety of guest operating systems on a host operating system, and can emulate a wide range of hardware platforms. QEMU has been created by Fabrice Bellard (also known for ffmpeg) QEMU can be used for a variety of purposes, including: Running legacy operating systems or software on modern hardware. Running multiple operating systems on a single host machine for testing or development purposes. Providing a safe and isolated environment for running untrusted or potentially malicious code. Developing and testing software for embedded devices or other specialized hardware platforms. Visit QEMU website to learn more How QEMU works QEMU works by emulating the hardware components of a computer, including the CPU, memory, storage devices, network adapters, and input/output devices. When a guest operating system is started, it runs on top of the emulated hardware, just as it would on a physical machine. The guest operating system sees the emulated hardware as if it were real, and interacts with it accordingly. QEMU can also provide virtualization capabilities, allowing multiple operating systems to run on a single host machine with minimal performance overhead. In this mode, QEMU uses hardware virtualization extensions (such as Intel VT-x or AMD-V) to provide isolated environments for each guest operating system. Using QEMU QEMU is a powerful and versatile tool that can be used for a variety of purposes, from running legacy software to testing new operating systems. With its ease of use and wide range of features, QEMU is a must-have tool for any system administrator or developer. Install sudo apt-get install qemu-system qemu-user-static binfmt-support","title":"Introduction to QEMU"},{"location":"image/qemu/#introduction-to-qemu","text":"","title":"Introduction to QEMU"},{"location":"image/qemu/#introduction","text":"QEMU , which stands for Quick Emulator , is an open-source software project that provides an emulation and virtualization framework. It is designed to run a variety of guest operating systems on a host operating system, and can emulate a wide range of hardware platforms. QEMU has been created by Fabrice Bellard (also known for ffmpeg) QEMU can be used for a variety of purposes, including: Running legacy operating systems or software on modern hardware. Running multiple operating systems on a single host machine for testing or development purposes. Providing a safe and isolated environment for running untrusted or potentially malicious code. Developing and testing software for embedded devices or other specialized hardware platforms. Visit QEMU website to learn more","title":"Introduction"},{"location":"image/qemu/#how-qemu-works","text":"QEMU works by emulating the hardware components of a computer, including the CPU, memory, storage devices, network adapters, and input/output devices. When a guest operating system is started, it runs on top of the emulated hardware, just as it would on a physical machine. The guest operating system sees the emulated hardware as if it were real, and interacts with it accordingly. QEMU can also provide virtualization capabilities, allowing multiple operating systems to run on a single host machine with minimal performance overhead. In this mode, QEMU uses hardware virtualization extensions (such as Intel VT-x or AMD-V) to provide isolated environments for each guest operating system.","title":"How QEMU works"},{"location":"image/qemu/#using-qemu","text":"QEMU is a powerful and versatile tool that can be used for a variety of purposes, from running legacy software to testing new operating systems. With its ease of use and wide range of features, QEMU is a must-have tool for any system administrator or developer.","title":"Using QEMU"},{"location":"image/qemu/#install","text":"sudo apt-get install qemu-system qemu-user-static binfmt-support","title":"Install"},{"location":"image/tp1/executing/","text":"E. Executing commands on the Raspberry Pi OS image Introduction Changing values in configuration files in the image on host is fairly easy (as seen before) But what about running a command in the image on host? for example to change the password ? Problem 1 Host executes X86 code while image contains ARM executables Solution : emulating ARM on X86 with QEMU (created by Fabrice Bellard) --> Read Introduction to QEMU Problem 2 Host commands are under / (ex /bin/bash) while image commands are under /mnt/rpi (ex /mnt/rpi/bin/bash). Solution : changing the root (/) using chroot, introduced in development of Version 7 Unix in 1979. Starting chroot Standard process Prepare the Raspberry Pi OS image to be executed it on host ... First we need to mount the system folder the same way they are mounted on the real Raspberry Pi board Mount the image in a loop device (we use /dev/loop50 as before) sudo losetup -P /dev/loop50 imgs/2024-11-19-raspios-bookworm-arm64-lite.img Mount the partitions (as before) sudo mount /dev/loop50p2 /mnt/rpi sudo mount /dev/loop50p1 /mnt/rpi/boot Mount the system folders to make them similar as if we were executing on the actual Raspberry board for example, /dev is an important folder that gives access to all the devices : /mnt/rpi/dev must be translated to /dev sudo mount --bind /dev /mnt/rpi/dev/ 1 - Issue Do the same for all the other system folders we need : /sys , which is an interface to the kernel /proc , which is a virtual file system working as an interface to ongoing processes 1 - Solution sudo mount --bind /sys /mnt/rpi/sys/ sudo mount --bind /proc /mnt/rpi/proc/ PTYs (/dev/pts/*), pseudo-terminals are provided by the devpts filesystem. Mount it using : sudo mount -t devpts devpts /mnt/rpi/dev/pts Note We need to disable some specific actions done solely on the real board. The /etc/ld.so.preload file tells what libraries should be loaded before the other. This does not work on the virtual Raspberry Pi. On modern Debian-based systems (including Raspberry Pi OS Bookworm = Debian 12) : /etc/ld.so.preload is optional It is not created by default The dynamic linker only reads it if it exists The file /etc/ld.so.preload should only be executed on actual board. Check if there is such a file : ls /mnt/rpi/etc/ld.so.preload It should return nothing. If it returns /mnt/rpi/etc/ld.so.preload , it means you are using an old version, then for safety keep a backup version and comment the content of /mnt/rpi/etc/ld.so.preload . We also need to add QEMU to translate ARM code to X86 64 code so it can be executed on the host computer. QEMU is added by just copying the emulator in the Raspberry Pi OS image : sudo cp /usr/bin/qemu-arm-static /mnt/rpi/usr/bin/ Warning Make sure you installed QEMU following Introduction to QEMU instructions Using host network in chroot For some applications, we may need access to Internet. A practical example is the use of the packet manager with apt We need to copy some of the host configuration files (here /etc/resolv.conf) on the image before running chroot First save the current config as a backup sudo cp /mnt/rpi/etc/resolv.conf /mnt/rpi/etc/resolv.conf.bck Copy config from host sudo cp /etc/resolv.conf /mnt/rpi/etc/resolv.conf Now all should be prepared correctly. start_chroot.bash To avoid reapeating the previous series of commands and make more easy the use of chroot we can create a bash script to run before chroot : start_chroot.bash . Example of a starting script. Create the file start_chroot.bash in rpilab. nano start_chroot.bash And copy the following : #!/bin/bash # command parameter ($1) is the path to the RPI image file # example of use : # source start_chroot.bash imgs/2024-11-19-raspios-bookworm-arm64-lite.img sudo losetup -P /dev/loop50 $1 sudo mount /dev/loop50p2 /mnt/rpi sudo mount /dev/loop50p1 /mnt/rpi/boot sudo mount --bind /dev /mnt/rpi/dev/ sudo mount --bind /sys /mnt/rpi/sys/ sudo mount --bind /proc /mnt/rpi/proc/ sudo mount --bind /dev/pts /mnt/rpi/dev/pts sudo cp /usr/bin/qemu-arm-static /mnt/rpi/usr/bin/ sudo cp /mnt/rpi/etc/resolv.conf /mnt/rpi/etc/resolv.conf.bck sudo cp /etc/resolv.conf /mnt/rpi/etc/resolv.conf Run chroot We can now chroot and run the RPI image as if it was on a actual board ! /mnt/rpi will be our new / and we execute /bin/bash to start a terminal 2 - Issue Use chroot to make /mnt/rpi the new root and start a bash terminal Tip The /bin/bash command is used to open a new bash shell We have now a root prompt # and we can execute commands on the RPI image, for example : to create an new user ue41 with root privileges (sudo) set locale to en US.UTF-8 using raspi-config (5 Localisation options) set keyboard to French layout using raspi-config to enable the console with raspi-config (to access the actual RPI board without network) for future use with real board (may be done later) run apt update Tip To leave the chroot shell, use Ctrl + D Note With some experience, we can do most of the setup of the RPI image without using the actual board !!! Adding a sudo user with chroot To do this, we make sure we are in chroot (# prompt) on the Raspberry PI OS, and we will proceed in two steps : We will create a new user called ue41, password ue41. (no need to answer all the questions !!! most of them can be left empty) 3 - Issue Use adduser to create the ue41 user Execute visudo command to give sudo permission to the created user visudo A file should open. Add a line with ue41 user here : %sudo ALL=(ALL:ALL) ALL ue41 ALL=(ALL:ALL) ALL Then write and save (nano commands) Enabling the RPI console for debug with chroot The console is an easy tool for debug, it can be connected to the host via FTDI USB cable and can be accessed on Ubuntu via /dev/ttyUSB0 device. Hence, it can work even if the network is not or badly defined. To enable the console, Raspberry Pi OS offers several ways : adding the line enable uart=1 at the end of the file /mnt/rpi/boot/config.txt with standard mount of boot partition, adding the line enable uart=1 at the end of the file boot/config.txt in chroot mode, use raspi-config in chroot mode. As we have started chroot, we will use the raspi-config tool. Simply execute raspi-config under chroot prompt # raspi-config Then go in Interface Options and enable Serial Port . More details on raspi-config Documetation Note raspi-config can be used to easily configure a lot of features such as the network, the locale language, etc Clean termination of chroot Standard process To exit chroot, just type ctrl+D or exit . To return to a standard host configuration we have to : go back to the original network config if we used the host's uncomment actions in /mnt/rpi/etc/ld.so.preload if we did so unmount all the RPI image system folders stop the loop device with RPI image Restore the network config sudo cp /mnt/rpi/etc/resolv.conf.bck /mnt/rpi/etc/resolv.conf Unmount all volumes at once sudo umount /mnt/rpi/ { dev/pts,dev,sys,proc,boot, } Stop the loop device with RPI image sudo losetup -d /dev/loop50 stop_chroot.bash Just like we did for starting chroot we can create a bash script to run after chroot: stop_chroot.bash 4 - Issue Write a stop_chroot.bash script to cleanly return to the standard host configuration. Run apt command in chroot Now with the scripts you should be able to only use the following : source start_chroot.bash imgs/2024-11-19-raspios-bookworm-arm64-lite.img sudo chroot /mnt/rpi /bin/bash apt update # type ctrl-D to exit chroot source stop_chroot.bash Congrats ! You successfully ended this lab ! Keep your modified image on your computer as it will be used in a next lab.","title":"E. Executing commands on the Raspberry Pi OS image"},{"location":"image/tp1/executing/#e-executing-commands-on-the-raspberry-pi-os-image","text":"","title":"E. Executing commands on the Raspberry Pi OS image"},{"location":"image/tp1/executing/#introduction","text":"Changing values in configuration files in the image on host is fairly easy (as seen before) But what about running a command in the image on host? for example to change the password ? Problem 1 Host executes X86 code while image contains ARM executables Solution : emulating ARM on X86 with QEMU (created by Fabrice Bellard) --> Read Introduction to QEMU Problem 2 Host commands are under / (ex /bin/bash) while image commands are under /mnt/rpi (ex /mnt/rpi/bin/bash). Solution : changing the root (/) using chroot, introduced in development of Version 7 Unix in 1979.","title":"Introduction"},{"location":"image/tp1/executing/#starting-chroot","text":"","title":"Starting chroot"},{"location":"image/tp1/executing/#standard-process","text":"Prepare the Raspberry Pi OS image to be executed it on host ... First we need to mount the system folder the same way they are mounted on the real Raspberry Pi board Mount the image in a loop device (we use /dev/loop50 as before) sudo losetup -P /dev/loop50 imgs/2024-11-19-raspios-bookworm-arm64-lite.img Mount the partitions (as before) sudo mount /dev/loop50p2 /mnt/rpi sudo mount /dev/loop50p1 /mnt/rpi/boot Mount the system folders to make them similar as if we were executing on the actual Raspberry board for example, /dev is an important folder that gives access to all the devices : /mnt/rpi/dev must be translated to /dev sudo mount --bind /dev /mnt/rpi/dev/ 1 - Issue Do the same for all the other system folders we need : /sys , which is an interface to the kernel /proc , which is a virtual file system working as an interface to ongoing processes 1 - Solution sudo mount --bind /sys /mnt/rpi/sys/ sudo mount --bind /proc /mnt/rpi/proc/ PTYs (/dev/pts/*), pseudo-terminals are provided by the devpts filesystem. Mount it using : sudo mount -t devpts devpts /mnt/rpi/dev/pts Note We need to disable some specific actions done solely on the real board. The /etc/ld.so.preload file tells what libraries should be loaded before the other. This does not work on the virtual Raspberry Pi. On modern Debian-based systems (including Raspberry Pi OS Bookworm = Debian 12) : /etc/ld.so.preload is optional It is not created by default The dynamic linker only reads it if it exists The file /etc/ld.so.preload should only be executed on actual board. Check if there is such a file : ls /mnt/rpi/etc/ld.so.preload It should return nothing. If it returns /mnt/rpi/etc/ld.so.preload , it means you are using an old version, then for safety keep a backup version and comment the content of /mnt/rpi/etc/ld.so.preload . We also need to add QEMU to translate ARM code to X86 64 code so it can be executed on the host computer. QEMU is added by just copying the emulator in the Raspberry Pi OS image : sudo cp /usr/bin/qemu-arm-static /mnt/rpi/usr/bin/ Warning Make sure you installed QEMU following Introduction to QEMU instructions","title":"Standard process"},{"location":"image/tp1/executing/#using-host-network-in-chroot","text":"For some applications, we may need access to Internet. A practical example is the use of the packet manager with apt We need to copy some of the host configuration files (here /etc/resolv.conf) on the image before running chroot First save the current config as a backup sudo cp /mnt/rpi/etc/resolv.conf /mnt/rpi/etc/resolv.conf.bck Copy config from host sudo cp /etc/resolv.conf /mnt/rpi/etc/resolv.conf Now all should be prepared correctly.","title":"Using host network in chroot"},{"location":"image/tp1/executing/#start_chrootbash","text":"To avoid reapeating the previous series of commands and make more easy the use of chroot we can create a bash script to run before chroot : start_chroot.bash . Example of a starting script. Create the file start_chroot.bash in rpilab. nano start_chroot.bash And copy the following : #!/bin/bash # command parameter ($1) is the path to the RPI image file # example of use : # source start_chroot.bash imgs/2024-11-19-raspios-bookworm-arm64-lite.img sudo losetup -P /dev/loop50 $1 sudo mount /dev/loop50p2 /mnt/rpi sudo mount /dev/loop50p1 /mnt/rpi/boot sudo mount --bind /dev /mnt/rpi/dev/ sudo mount --bind /sys /mnt/rpi/sys/ sudo mount --bind /proc /mnt/rpi/proc/ sudo mount --bind /dev/pts /mnt/rpi/dev/pts sudo cp /usr/bin/qemu-arm-static /mnt/rpi/usr/bin/ sudo cp /mnt/rpi/etc/resolv.conf /mnt/rpi/etc/resolv.conf.bck sudo cp /etc/resolv.conf /mnt/rpi/etc/resolv.conf","title":"start_chroot.bash"},{"location":"image/tp1/executing/#run-chroot","text":"We can now chroot and run the RPI image as if it was on a actual board ! /mnt/rpi will be our new / and we execute /bin/bash to start a terminal 2 - Issue Use chroot to make /mnt/rpi the new root and start a bash terminal Tip The /bin/bash command is used to open a new bash shell We have now a root prompt # and we can execute commands on the RPI image, for example : to create an new user ue41 with root privileges (sudo) set locale to en US.UTF-8 using raspi-config (5 Localisation options) set keyboard to French layout using raspi-config to enable the console with raspi-config (to access the actual RPI board without network) for future use with real board (may be done later) run apt update Tip To leave the chroot shell, use Ctrl + D Note With some experience, we can do most of the setup of the RPI image without using the actual board !!!","title":"Run chroot"},{"location":"image/tp1/executing/#adding-a-sudo-user-with-chroot","text":"To do this, we make sure we are in chroot (# prompt) on the Raspberry PI OS, and we will proceed in two steps : We will create a new user called ue41, password ue41. (no need to answer all the questions !!! most of them can be left empty) 3 - Issue Use adduser to create the ue41 user Execute visudo command to give sudo permission to the created user visudo A file should open. Add a line with ue41 user here : %sudo ALL=(ALL:ALL) ALL ue41 ALL=(ALL:ALL) ALL Then write and save (nano commands)","title":"Adding a sudo user with chroot"},{"location":"image/tp1/executing/#enabling-the-rpi-console-for-debug-with-chroot","text":"The console is an easy tool for debug, it can be connected to the host via FTDI USB cable and can be accessed on Ubuntu via /dev/ttyUSB0 device. Hence, it can work even if the network is not or badly defined. To enable the console, Raspberry Pi OS offers several ways : adding the line enable uart=1 at the end of the file /mnt/rpi/boot/config.txt with standard mount of boot partition, adding the line enable uart=1 at the end of the file boot/config.txt in chroot mode, use raspi-config in chroot mode. As we have started chroot, we will use the raspi-config tool. Simply execute raspi-config under chroot prompt # raspi-config Then go in Interface Options and enable Serial Port . More details on raspi-config Documetation Note raspi-config can be used to easily configure a lot of features such as the network, the locale language, etc","title":"Enabling the RPI console for debug with chroot"},{"location":"image/tp1/executing/#clean-termination-of-chroot","text":"","title":"Clean termination of chroot"},{"location":"image/tp1/executing/#standard-process_1","text":"To exit chroot, just type ctrl+D or exit . To return to a standard host configuration we have to : go back to the original network config if we used the host's uncomment actions in /mnt/rpi/etc/ld.so.preload if we did so unmount all the RPI image system folders stop the loop device with RPI image Restore the network config sudo cp /mnt/rpi/etc/resolv.conf.bck /mnt/rpi/etc/resolv.conf Unmount all volumes at once sudo umount /mnt/rpi/ { dev/pts,dev,sys,proc,boot, } Stop the loop device with RPI image sudo losetup -d /dev/loop50","title":"Standard process"},{"location":"image/tp1/executing/#stop_chrootbash","text":"Just like we did for starting chroot we can create a bash script to run after chroot: stop_chroot.bash 4 - Issue Write a stop_chroot.bash script to cleanly return to the standard host configuration.","title":"stop_chroot.bash"},{"location":"image/tp1/executing/#run-apt-command-in-chroot","text":"Now with the scripts you should be able to only use the following : source start_chroot.bash imgs/2024-11-19-raspios-bookworm-arm64-lite.img sudo chroot /mnt/rpi /bin/bash apt update # type ctrl-D to exit chroot source stop_chroot.bash Congrats ! You successfully ended this lab ! Keep your modified image on your computer as it will be used in a next lab.","title":"Run apt command in chroot"},{"location":"image/tp1/getting/","text":"A. Getting the Raspberry Pi OS image Create the working directory mkdir rpilab && cd rpilab Create a folder for the images mkdir imgs && cd imgs Let's choose the \"lite\" version of raspios bookworm (from 2024, November 19th) 1 - Issue Download the image in the lab from the official website: https://www.raspberrypi.com/software/operating-systems/ Click on \"View archive\" to get this version and download it using the wget command. 1 - Solution wget https://downloads.raspberrypi.com/raspios_lite_arm64/images/raspios_lite_arm64-2024-11-19/2024-11-19-raspios-bookworm-arm64-lite.img.xz Now, we want to check the checksum to ensure data integrity and avoid any problem during the download 2 - Issue Download the cheksum file ( .sha256 file) using wget Compute the checksum using the sha256sum command Verify that the resulting code is the same as the one contained in the .sha256 file, using cat to display the file's content in the shell 2 - Solution First, we download the checksum file wget https://downloads.raspberrypi.com/raspios_lite_arm64/images/raspios_lite_arm64-2024-11-19/2024-11-19-raspios-bookworm-arm64-lite.img.xz.sha256 Then, we compute the checksum sha256sum 2024 -11-19-raspios-bookworm-arm64-lite.img.xz Finally, we check that the code is the same cat 2024 -11-19-raspios-bookworm-arm64-lite.img.xz.sha256 3 - Issue We can now safely decrompress the image using xz . 3 - Solution xz -d 2024 -11-19-raspios-bookworm-arm64-lite.img.xz We go back in the lab folder cd ..","title":"A. Getting the Raspberry Pi OS image"},{"location":"image/tp1/getting/#a-getting-the-raspberry-pi-os-image","text":"Create the working directory mkdir rpilab && cd rpilab Create a folder for the images mkdir imgs && cd imgs Let's choose the \"lite\" version of raspios bookworm (from 2024, November 19th) 1 - Issue Download the image in the lab from the official website: https://www.raspberrypi.com/software/operating-systems/ Click on \"View archive\" to get this version and download it using the wget command. 1 - Solution wget https://downloads.raspberrypi.com/raspios_lite_arm64/images/raspios_lite_arm64-2024-11-19/2024-11-19-raspios-bookworm-arm64-lite.img.xz Now, we want to check the checksum to ensure data integrity and avoid any problem during the download 2 - Issue Download the cheksum file ( .sha256 file) using wget Compute the checksum using the sha256sum command Verify that the resulting code is the same as the one contained in the .sha256 file, using cat to display the file's content in the shell 2 - Solution First, we download the checksum file wget https://downloads.raspberrypi.com/raspios_lite_arm64/images/raspios_lite_arm64-2024-11-19/2024-11-19-raspios-bookworm-arm64-lite.img.xz.sha256 Then, we compute the checksum sha256sum 2024 -11-19-raspios-bookworm-arm64-lite.img.xz Finally, we check that the code is the same cat 2024 -11-19-raspios-bookworm-arm64-lite.img.xz.sha256 3 - Issue We can now safely decrompress the image using xz . 3 - Solution xz -d 2024 -11-19-raspios-bookworm-arm64-lite.img.xz We go back in the lab folder cd ..","title":"A. Getting the Raspberry Pi OS image"},{"location":"image/tp1/increasing/","text":"C. Increasing size of Raspberry Pi OS image Suppose that we are in the rpilab folder, go to imgs subfolder : cd imgs Extend partition 2 (rootfs) with 2 GB (choose one of the two methods) method 1 : truncate --size = +2G 2024 -11-19-raspios-bookworm-arm64-lite.img method 2 : dd if = /dev/zero bs = 1M count = 2048 >> 2024 -11-19-raspios-bookworm-arm64-lite.img Check that partition 2 has not been resized yet sudo fdisk -l 2024 -11-19-raspios-bookworm-arm64-lite.img Then, use parted to actually extend the partition 2 sudo parted 2024 -11-19-raspios-bookworm-arm64-lite.img On the command prompt,type: p resizepart 2 -1 p q Mount the image in a loop device (we use /dev/loop50 as before) sudo losetup -P /dev/loop50 2024 -11-19-raspios-bookworm-arm64-lite.img Check file system and extend file system to fully fill partition 2 sudo e2fsck -f /dev/loop50p2 sudo resize2fs /dev/loop50p2 Detach cleanly sudo losetup -d /dev/loop50 back to rpilab folder cd ..","title":"C. Increasing size of Raspberry Pi OS image"},{"location":"image/tp1/increasing/#c-increasing-size-of-raspberry-pi-os-image","text":"Suppose that we are in the rpilab folder, go to imgs subfolder : cd imgs Extend partition 2 (rootfs) with 2 GB (choose one of the two methods) method 1 : truncate --size = +2G 2024 -11-19-raspios-bookworm-arm64-lite.img method 2 : dd if = /dev/zero bs = 1M count = 2048 >> 2024 -11-19-raspios-bookworm-arm64-lite.img Check that partition 2 has not been resized yet sudo fdisk -l 2024 -11-19-raspios-bookworm-arm64-lite.img Then, use parted to actually extend the partition 2 sudo parted 2024 -11-19-raspios-bookworm-arm64-lite.img On the command prompt,type: p resizepart 2 -1 p q Mount the image in a loop device (we use /dev/loop50 as before) sudo losetup -P /dev/loop50 2024 -11-19-raspios-bookworm-arm64-lite.img Check file system and extend file system to fully fill partition 2 sudo e2fsck -f /dev/loop50p2 sudo resize2fs /dev/loop50p2 Detach cleanly sudo losetup -d /dev/loop50 back to rpilab folder cd ..","title":"C. Increasing size of Raspberry Pi OS image"},{"location":"image/tp1/intro/","text":"Lab 1 \u2013 Setting up Raspberry Pi OS image\u200b Objectives Getting the Raspberry Pi OS (formerly Raspbian) image Modifying the image on the host OS (ex. increasing size, changing settings) Executing commands on the image on the host computer (ex. adding a sudo user, raspi-config) Note The host or the host computer is the physical machine on which you will execute the Raspberry Pi OS. In this lab it is your laptop. Raspberry Pi 3B Overview : The Raspberry Pi is a small single-board computer developed in the UK by the Raspberry Pi Foundation. The Raspberry Pi 3 Model B is one of the most popular versions. It offers a low-cost, compact solution for various computing projects. Specifications : CPU: Quad-core 1.2GHz Broadcom BCM2837 64-bit ARM Cortex-A53 processor RAM: 1GB LPDDR2 Connectivity: 4 USB 2.0 ports 1 HDMI port 1 Ethernet port 3.5mm audio jack Wi-Fi 802.11n and Bluetooth 4.1 GPIO: 40-pin GPIO header Applications : Home automation Robotics IoT projects Media center Education Retro gaming console Linux on RPI Very basic behavior description : Linux comes as an image file (Raspberry Pi OS, Ubuntu, Fedora, Manjaro ARM, ...) We will use the official image Raspberry Pi OS On real boards, the image is written on a SD-CARD The Raspberry Pi OS image contains 2 partitions : boot and rootfs The boot partition contains all the important elements for starting linux : boot loader (bootcode.bin), Device Tree Blob (.dtb) , kernel (kernelx.img), starting command (cmdline.txt) , configuration (config.txt) ... The rootfs partition contains file system : /etc /lib /usr/lib, /bin /dev /opt /home ... Lab presentation In this lab you are asked to follow given instructions. Sometimes, you will meet issues you need to solve. There are tips to help you. The solutions will be displayed after the class.","title":"Lab 1 \u2013 Setting up Raspberry Pi OS image\u200b"},{"location":"image/tp1/intro/#lab-1-setting-up-raspberry-pi-os-image","text":"","title":"Lab 1 \u2013 Setting up Raspberry Pi OS image\u200b"},{"location":"image/tp1/intro/#objectives","text":"Getting the Raspberry Pi OS (formerly Raspbian) image Modifying the image on the host OS (ex. increasing size, changing settings) Executing commands on the image on the host computer (ex. adding a sudo user, raspi-config) Note The host or the host computer is the physical machine on which you will execute the Raspberry Pi OS. In this lab it is your laptop.","title":"Objectives"},{"location":"image/tp1/intro/#raspberry-pi-3b","text":"Overview : The Raspberry Pi is a small single-board computer developed in the UK by the Raspberry Pi Foundation. The Raspberry Pi 3 Model B is one of the most popular versions. It offers a low-cost, compact solution for various computing projects. Specifications : CPU: Quad-core 1.2GHz Broadcom BCM2837 64-bit ARM Cortex-A53 processor RAM: 1GB LPDDR2 Connectivity: 4 USB 2.0 ports 1 HDMI port 1 Ethernet port 3.5mm audio jack Wi-Fi 802.11n and Bluetooth 4.1 GPIO: 40-pin GPIO header Applications : Home automation Robotics IoT projects Media center Education Retro gaming console","title":"Raspberry Pi 3B"},{"location":"image/tp1/intro/#linux-on-rpi","text":"Very basic behavior description : Linux comes as an image file (Raspberry Pi OS, Ubuntu, Fedora, Manjaro ARM, ...) We will use the official image Raspberry Pi OS On real boards, the image is written on a SD-CARD The Raspberry Pi OS image contains 2 partitions : boot and rootfs The boot partition contains all the important elements for starting linux : boot loader (bootcode.bin), Device Tree Blob (.dtb) , kernel (kernelx.img), starting command (cmdline.txt) , configuration (config.txt) ... The rootfs partition contains file system : /etc /lib /usr/lib, /bin /dev /opt /home ...","title":"Linux on RPI"},{"location":"image/tp1/intro/#lab-presentation","text":"In this lab you are asked to follow given instructions. Sometimes, you will meet issues you need to solve. There are tips to help you. The solutions will be displayed after the class.","title":"Lab presentation"},{"location":"image/tp1/modifying/","text":"D. Modifying the Raspberry Pi OS image 1 - Issue First mount the image's root file system as you have done before using losetup and mount 1 - Solution sudo losetup -P /dev/loop50 imgs/2024-11-19-raspios-bookworm-arm64-lite.img sudo mount /dev/loop50p2 /mnt/rpi Now the image is mounted, we can modify it (writing files, configuring parameters, etc). 2 - Issue Change the name raspberrypi name with the name of your choice : In the /etc/hosts file of the Raspberry Pi OS image, which is used to translate the host name into its ip address. In the /etc/hostname file of the Raspberry Pi OS image, which is used to define the hostname Warning Be careful not to modify your local OS' files, but those in /mnt/rpi 2 - Solution Change the name raspberry with the name you have chosen before : sudo nano /mnt/rpi/etc/hosts sudo nano /mnt/rpi/etc/hostname Clean end sudo umount /mnt/rpi sudo losetup -d /dev/loop50","title":"D. Modifying the Raspberry Pi OS image"},{"location":"image/tp1/modifying/#d-modifying-the-raspberry-pi-os-image","text":"1 - Issue First mount the image's root file system as you have done before using losetup and mount 1 - Solution sudo losetup -P /dev/loop50 imgs/2024-11-19-raspios-bookworm-arm64-lite.img sudo mount /dev/loop50p2 /mnt/rpi Now the image is mounted, we can modify it (writing files, configuring parameters, etc). 2 - Issue Change the name raspberrypi name with the name of your choice : In the /etc/hosts file of the Raspberry Pi OS image, which is used to translate the host name into its ip address. In the /etc/hostname file of the Raspberry Pi OS image, which is used to define the hostname Warning Be careful not to modify your local OS' files, but those in /mnt/rpi 2 - Solution Change the name raspberry with the name you have chosen before : sudo nano /mnt/rpi/etc/hosts sudo nano /mnt/rpi/etc/hostname Clean end sudo umount /mnt/rpi sudo losetup -d /dev/loop50","title":"D. Modifying the Raspberry Pi OS image"},{"location":"image/tp1/mounting/","text":"B. Mounting the Raspberry Pi OS image on the host The Raspberry Pi OS image has 2 partitions : rootfs and boot. We will now mount these partitions on the host to get access to the files and folders in the image. The boot partition contains bootloader information (used at start). The rootfs partition contains the file system of raspios bookworm. Definition Mounting a partition is the act of making the filesystem on that partition accessible at a specific location in the directory tree so the operating system can read from and write to it. We will now mount the rootfs partition on our computer to have access to the file system of raspios bookworm. Note We will go throuhg 2 different methods. The first one will teach us more how the image is structured. The second one is more efficient and recommended. First method (Intuitive) 1 - Issue Use the fdisk command with the correct option to display a list of partitions in your img file You may use sudo to get permission Tip Use fdisk -h to learn more about the existing options 1 - Solution sudo fdisk -l imgs/2024-11-19-raspios-bookworm-arm64-lite.img You must get something like: Disk imgs/2024-11-19-raspios-bookworm-arm64-lite.img: 2 .57 GiB, 2755657728 bytes, 5382144 sectors Units: sectors of 1 * 512 = 512 bytes Sector size ( logical/physical ) : 512 bytes / 512 bytes I/O size ( minimum/optimal ) : 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x8a438930 Device Boot Start End Sectors Size Id Type imgs/2024-11-19-raspios-bookworm-arm64-lite.img1 8192 1056767 1048576 512M c W95 FAT32 ( LBA ) imgs/2024-11-19-raspios-bookworm-arm64-lite.img2 1056768 5382143 4325376 2 .1G 83 Linux Get the starting point of the partitions contained in the image Here, partition 1 (boot) starts at block 8192 and partition2 (rootfs) starts at block 1056768. The block size is 512 bytes. Check yours Note Why does the first partition start at sector 8192 ? In order to leave space at the beginning for : Bootloader data Alignment (important for SD cards) This is common in Raspberry Pi images We first create an access file to mount the main partition (partition 2) on our computer sudo mkdir -p /mnt/rpi Note The /mnt mount directory is where external partitions are located when mounted on Linux Ubuntu. For example when you plug an external storage device (SSD, USB key, etc) Then we will use the mount command to mount the partitions. This is the standard way to mount a partition, i.e. to give access to the folders and files on the partition. Note mount automatically detect the partition type (linux ext4, dos, ntfs, ...). We mount partition 2 with the root file system sudo mount -o loop,offset = $(( 1056768 * 512 )) imgs/2024-11-19-raspios-bookworm-arm64-lite.img /mnt/rpi We check that the file system of Raspberry PI OS is there : ls /mnt/rpi Then we unmount the partition sudo umount /mnt/rpi We create an access file to mount the other partition (partition 1) sudo mkdir -p /mnt/rpi/boot sudo mount -o loop,offset = $(( 8192 * 512 )) imgs/2024-11-19-raspios-bookworm-arm64-lite.img /mnt/rpi/boot We can display the content of the boot folder : ls /mnt/rpi/boot and we unmount the partition to cleanly exit sudo umount /mnt/rpi/boot sudo rmdir /mnt/rpi/boot Warning The main problem of this method is that we cannot mount simultaneously the two partitions at the right places /mnt/rpi and /mnt/rpi/boot because an overlapping error occurs. Second method (Recommended) loop devices are virtual block devices that map a file to a disk-like interface. They let Linux treat a regular file as if it were a real disk or partition. We search for a non used loop device (/dev/loop??), list existing loop devices : lsblk For example /dev/loop50 is not used on my computer, I will use it here. 2 - Issue The losetup command allows controlling loop devices. Learn how to use the -P option in order to create a partitioned loop device, say /dev/loop50 from your Raspberry Pi OS image. Tip Use losetup -P <loop_device> <img> 2 - Solution sudo losetup -P /dev/loop50 imgs/2024-11-19-raspios-bookworm-arm64-lite.img The -P option find the 2 partitions and give them these names : partition 1 : /dev/loop50p1 (name: boot) partition 2 : /dev/loop50p2 (name: rootfs) Check your loop devices with lsblk 3 - Issue Create a folder to access the mount (already done before in method 1 !) Then, mount partition 2 with the root file system using mount (no need for the -o option) Finally, mount the boot partition at the right place in the root file system : look for a boot directory Tip You should use sudo mount <source> <directory> 3 - Solution Create the folder to access the mount sudo mkdir -p /mnt/rpi Then mount the file system partition (rootfs) sudo mount /dev/loop50p2 /mnt/rpi ls /mnt/rpi and mount the boot partition sudo mount /dev/loop50p1 /mnt/rpi/boot ls /mnt/rpi/boot Finally, we unmount the partitions to cleanly exit sudo umount /mnt/rpi/boot sudo umount /mnt/rpi sudo losetup -d /dev/loop50 Warning To cleanly exit : make the last 3 commands, in the right order, do not execute the next command if the previous has failed.","title":"B. Mounting the Raspberry Pi OS image on the host"},{"location":"image/tp1/mounting/#b-mounting-the-raspberry-pi-os-image-on-the-host","text":"The Raspberry Pi OS image has 2 partitions : rootfs and boot. We will now mount these partitions on the host to get access to the files and folders in the image. The boot partition contains bootloader information (used at start). The rootfs partition contains the file system of raspios bookworm. Definition Mounting a partition is the act of making the filesystem on that partition accessible at a specific location in the directory tree so the operating system can read from and write to it. We will now mount the rootfs partition on our computer to have access to the file system of raspios bookworm. Note We will go throuhg 2 different methods. The first one will teach us more how the image is structured. The second one is more efficient and recommended.","title":"B. Mounting the Raspberry Pi OS image on the host"},{"location":"image/tp1/mounting/#first-method-intuitive","text":"1 - Issue Use the fdisk command with the correct option to display a list of partitions in your img file You may use sudo to get permission Tip Use fdisk -h to learn more about the existing options 1 - Solution sudo fdisk -l imgs/2024-11-19-raspios-bookworm-arm64-lite.img You must get something like: Disk imgs/2024-11-19-raspios-bookworm-arm64-lite.img: 2 .57 GiB, 2755657728 bytes, 5382144 sectors Units: sectors of 1 * 512 = 512 bytes Sector size ( logical/physical ) : 512 bytes / 512 bytes I/O size ( minimum/optimal ) : 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x8a438930 Device Boot Start End Sectors Size Id Type imgs/2024-11-19-raspios-bookworm-arm64-lite.img1 8192 1056767 1048576 512M c W95 FAT32 ( LBA ) imgs/2024-11-19-raspios-bookworm-arm64-lite.img2 1056768 5382143 4325376 2 .1G 83 Linux Get the starting point of the partitions contained in the image Here, partition 1 (boot) starts at block 8192 and partition2 (rootfs) starts at block 1056768. The block size is 512 bytes. Check yours Note Why does the first partition start at sector 8192 ? In order to leave space at the beginning for : Bootloader data Alignment (important for SD cards) This is common in Raspberry Pi images We first create an access file to mount the main partition (partition 2) on our computer sudo mkdir -p /mnt/rpi Note The /mnt mount directory is where external partitions are located when mounted on Linux Ubuntu. For example when you plug an external storage device (SSD, USB key, etc) Then we will use the mount command to mount the partitions. This is the standard way to mount a partition, i.e. to give access to the folders and files on the partition. Note mount automatically detect the partition type (linux ext4, dos, ntfs, ...). We mount partition 2 with the root file system sudo mount -o loop,offset = $(( 1056768 * 512 )) imgs/2024-11-19-raspios-bookworm-arm64-lite.img /mnt/rpi We check that the file system of Raspberry PI OS is there : ls /mnt/rpi Then we unmount the partition sudo umount /mnt/rpi We create an access file to mount the other partition (partition 1) sudo mkdir -p /mnt/rpi/boot sudo mount -o loop,offset = $(( 8192 * 512 )) imgs/2024-11-19-raspios-bookworm-arm64-lite.img /mnt/rpi/boot We can display the content of the boot folder : ls /mnt/rpi/boot and we unmount the partition to cleanly exit sudo umount /mnt/rpi/boot sudo rmdir /mnt/rpi/boot Warning The main problem of this method is that we cannot mount simultaneously the two partitions at the right places /mnt/rpi and /mnt/rpi/boot because an overlapping error occurs.","title":"First method (Intuitive)"},{"location":"image/tp1/mounting/#second-method-recommended","text":"loop devices are virtual block devices that map a file to a disk-like interface. They let Linux treat a regular file as if it were a real disk or partition. We search for a non used loop device (/dev/loop??), list existing loop devices : lsblk For example /dev/loop50 is not used on my computer, I will use it here. 2 - Issue The losetup command allows controlling loop devices. Learn how to use the -P option in order to create a partitioned loop device, say /dev/loop50 from your Raspberry Pi OS image. Tip Use losetup -P <loop_device> <img> 2 - Solution sudo losetup -P /dev/loop50 imgs/2024-11-19-raspios-bookworm-arm64-lite.img The -P option find the 2 partitions and give them these names : partition 1 : /dev/loop50p1 (name: boot) partition 2 : /dev/loop50p2 (name: rootfs) Check your loop devices with lsblk 3 - Issue Create a folder to access the mount (already done before in method 1 !) Then, mount partition 2 with the root file system using mount (no need for the -o option) Finally, mount the boot partition at the right place in the root file system : look for a boot directory Tip You should use sudo mount <source> <directory> 3 - Solution Create the folder to access the mount sudo mkdir -p /mnt/rpi Then mount the file system partition (rootfs) sudo mount /dev/loop50p2 /mnt/rpi ls /mnt/rpi and mount the boot partition sudo mount /dev/loop50p1 /mnt/rpi/boot ls /mnt/rpi/boot Finally, we unmount the partitions to cleanly exit sudo umount /mnt/rpi/boot sudo umount /mnt/rpi sudo losetup -d /dev/loop50 Warning To cleanly exit : make the last 3 commands, in the right order, do not execute the next command if the previous has failed.","title":"Second method (Recommended)"},{"location":"image/tp2/getting/","text":"A. Getting the Raspberry Pi OS image Note There is no need to do this again if you have done it the previous lab, just be sure you have cleaned the changes made in the image to use it in chroot. Follow the instructions in Getting the Raspberry Pi OS image from the previous lab.","title":"A. Getting the Raspberry Pi OS image"},{"location":"image/tp2/getting/#a-getting-the-raspberry-pi-os-image","text":"Note There is no need to do this again if you have done it the previous lab, just be sure you have cleaned the changes made in the image to use it in chroot. Follow the instructions in Getting the Raspberry Pi OS image from the previous lab.","title":"A. Getting the Raspberry Pi OS image"},{"location":"image/tp2/installVM/","text":"B. Install QEMU ARM virtual machine (VM) Install require packages for QEMU virtual machine (QEMU VM). Update package manager sudo apt-get update Install packages for the QEMU VM sudo apt-get install qemu-system-arm \\ qemu-kvm libvirt-clients libvirt-daemon-system bridge-utils \\ virtinst libvirt-daemon virt-manager If problems with lmv2 during install sudo apt-get purge lvm2 sudo apt-get install lvm2 When running Raspberry PI OS in the QEMU VM, we need the Linux kernel and drivers to be compatible with an execution on a QEMU VM instead of the actual RPI board. They are available here : https://github.com/dhruvvyas90/qemu-rpi-kernel We assume that we are in the rpilab folder clone the git repo with kernels and drivers git clone https://github.com/dhruvvyas90/qemu-rpi-kernel to avoid problems of git submodules, you can remove the .git folder rm -Rf qemu-rpi-kernel/.git","title":"B. Install QEMU ARM virtual machine (VM)"},{"location":"image/tp2/installVM/#b-install-qemu-arm-virtual-machine-vm","text":"Install require packages for QEMU virtual machine (QEMU VM). Update package manager sudo apt-get update Install packages for the QEMU VM sudo apt-get install qemu-system-arm \\ qemu-kvm libvirt-clients libvirt-daemon-system bridge-utils \\ virtinst libvirt-daemon virt-manager If problems with lmv2 during install sudo apt-get purge lvm2 sudo apt-get install lvm2 When running Raspberry PI OS in the QEMU VM, we need the Linux kernel and drivers to be compatible with an execution on a QEMU VM instead of the actual RPI board. They are available here : https://github.com/dhruvvyas90/qemu-rpi-kernel We assume that we are in the rpilab folder clone the git repo with kernels and drivers git clone https://github.com/dhruvvyas90/qemu-rpi-kernel to avoid problems of git submodules, you can remove the .git folder rm -Rf qemu-rpi-kernel/.git","title":"B. Install QEMU ARM virtual machine (VM)"},{"location":"image/tp2/intro/","text":"Introduction Objectives Getting the Raspberry Pi OS (formerly Raspbian) image Installing Virtual Machine (QEMU VM) software on the host Preparing the image to run it in the QEMU VM Executing QEMU VM Installing ROS2 from source code or using docker Note The host or the host computer is the physical machine on which you will execute the Raspberry Pi OS. In this lab it is your laptop.","title":"Introduction"},{"location":"image/tp2/intro/#introduction","text":"","title":"Introduction"},{"location":"image/tp2/intro/#objectives","text":"Getting the Raspberry Pi OS (formerly Raspbian) image Installing Virtual Machine (QEMU VM) software on the host Preparing the image to run it in the QEMU VM Executing QEMU VM Installing ROS2 from source code or using docker Note The host or the host computer is the physical machine on which you will execute the Raspberry Pi OS. In this lab it is your laptop.","title":"Objectives"}]}